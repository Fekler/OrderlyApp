# Tarefa 1: Criação de uma aplicação Web

O setor de vendas de uma empresa precisa de uma ferramenta para gerenciar pedidos de clientes e acompanhar as vendas de forma eficiente. Seu desafio será desenvolver uma aplicação web que atenda a essa necessidade.

## Requisitos Obrigatórios:

A aplicação deve incluir:
- **Autenticação e Controle de Acesso:**
    - Implementação de login seguro utilizando JWT
    - Diferentes perfis de usuário com permissões específicas:
        - **Administrador**: acesso total ao sistema e gestão de usuários
        - **Cliente**: pode visualizar a lista de produtos e realizar pedidos
        - **Vendedor**: gerencia o estoque e aprova ou rejeita pedidos
- **Gestão de Pedidos:**
        - Os pedidos devem ser acompanhados pelo sistema e conter um status atualizado (ex: "Em andamento", "Finalizado", "Cancelado").
        - Todas as vendas devem ser registradas e armazenadas no banco de dados.
- **Visão Gerencial:**
        - A aplicação deve exibir relatórios e/ou gráficos dinâmicos contendo:
            - Resumo das vendas (total de pedidos, valor faturado, produtos vendidos).
            - Pedidos pendentes
            - Clientes mais ativos
- **Qualidade e Manutenibilidade:**
    - O projeto deve seguir boas práticas de organização de código e estruturação do repositório.
    - Deve conter testes unitários e testes de integração para garantir a confiabilidade da aplicação.

# Tarefa 2: CI/CD

Após a criação da aplicação, será necessário configurar um processo automatizado de Integração Contínua e Entrega Contínua (CI/CD) para disponibilizá-la na internet.

## Requisitos Obrigatórios:
- Criar uma **pipeline de CI/CD** utilizando ferramentas como **GitHub Actions, GitLab CI, Jenkins ou similares**.
- A pipeline deve conter **pelo menos três etapas principais**:
    - **Build**: Compilação e empacotamento da aplicação.
    - **Dockerização**: Criação de um Dockerfile funcional e, opcionalmente, um docker-compose.
    - **Deploy**: Publicação automática da aplicação em um ambiente de nuvem (ex: AWS, Azure, Vercel, Render, Heroku).

## Diferenciais (Extras - Não Obrigatórios, Mas Valorizados):
- Adicionar etapas para execução automatizada de testes dentro da pipeline.
- Incluir ferramentas de análise de qualidade de código
- Implementar verificação de segurança antes do deploy
- Configuração de diferentes pipelines para desenvolvimento, homologação e produção
- Configuração de logs estruturados e alertas automatizados em caso de falha na execução da pipeline 
- Implementação de métricas e dashboards para monitoramento da aplicação

# Entrega e Avaliação

1. A modelagem do banco de dados, organização do código, estrutura do repositório e interface gráfica serão avaliados.
2. A aplicação deve estar acessível online, e as instruções de acesso devem ser fornecidas.
3. O candidato deve enviar o link do repositório contendo o código-fonte da solução.



Tendo em vista o projeto já foi gerado a API que está rodando em https://sales-dev-api.fekler.tec.br/api/

Entities :
using SalesOrderManagement.Domain.Validations;
using SalesOrderManagement.Domain.Errors;

namespace SalesOrderManagement.Domain.Entities._bases
{
    public abstract class EntityBase
    {
        public int Id { get; set; }
        public Guid UUID { get; set; }
        public DateTime CreateAt { get; set; }
        public DateTime? UpdateAt { get; set; }

        protected EntityBase()
        {

        }

        protected EntityBase(Guid? uuid = null, DateTime? createAt = null, int? id = null)
        {
            InitializeEntity(uuid, createAt, id);
        }

        protected virtual void InitializeEntity(Guid? uuid, DateTime? createAt, int? id)
        {
            if (!id.HasValue)
            {
                CreateAt = DateTime.UtcNow;
                UUID = Guid.CreateVersion7();
            }
            else
            {
                Id = id.Value;
                UpdateAt = DateTime.UtcNow;
                CreateAt = createAt.Value;
                UUID = uuid.Value;
            }
        }

        public virtual void Validate()
        {
            //InitializeEntity(this.UUID, this.CreateAt, this.Id);

            RuleValidator.Build()
                .When(Id < 0, Error.INVALID_ID)
                .When(UUID == Guid.Empty, Error.INVALID_UUID)
                .When(Id > 0 && CreateAt == default, Error.INVALID_DATE)
                .ThrowExceptionIfExists();
        }
    }
}
namespace SalesOrderManagement.Domain.Entities._bases
{
    public static class Const
    {
        #region Properties
        public const int NAME_MAX_LENGTH = 255;
        public const int DESCRIPTION_MAX_LENGTH = 1000;
        public const int EMAIL_MAX_LENGTH = 255;
        public const int PHONE_MAX_LENGTH = 20;
        public const int DOCUMENT_MAX_LENGTH = 18;
        public const int CATEGORY_MAX_LENGTH = 100;
        public const int ADDRESS_MAX_LENGTH = 100;
        #endregion



        #region Messages
        public const string SYSTEM_SUCCESS = "System success";
        public const string CREATE_SUCCESS = "Create success";
        public const string UPDATE_SUCCESS = "Update success";
        public const string DELETE_SUCCESS = "Delete success";

        public const string MESSAGE_USER_FOUND = "User found";
        public const string MESSAGE_LOGIN_SUCCESS = "Login successful";
        #endregion
    }
}
namespace SalesOrderManagement.Domain.Entities._bases
{
    public class Enums
    {
        public enum UserRole
        {
            Client,
            Seller,
            Admin
        }
        public enum OrderStatus
        {
            Pending,
            Processing,
            Shipped,
            Delivered,
            Cancelled,
            Approved
        }
        public enum PaymentMethod
        {
            CreditCard,
            DebitCard,
            BankTransfer,
            Cash,
            Pix
        }

    }
}
using SalesOrderManagement.Domain.Entities._bases;
using SalesOrderManagement.Domain.Errors;
using SalesOrderManagement.Domain.Validations;
using static SalesOrderManagement.Domain.Entities._bases.Enums;

namespace SalesOrderManagement.Domain.Entities
{
    public class Order : EntityBase
    {
        public string OrderNumber { get; set; }
        public DateTime OrderDate { get; set; }
        public decimal TotalAmount { get; set; }
        public string ShippingAddress { get; set; }
        public string BillingAddress { get; set; }
        public PaymentMethod PaymentMethod { get; set; }
        public OrderStatus Status { get; set; }
        public Guid CreateByUserUuid { get; set; }
        public User CreateByUser { get; set; }

        public Guid? ActionedByUserUuid { get; set; }
        public User ActionedByUser { get; set; }
        public DateTime? ActionedAt { get; set; }

        public ICollection<OrderItem> OrderItems { get; set; } = [];


        public Order()
        {
            if (string.IsNullOrWhiteSpace(OrderNumber))
                GenerateOrderNumber();
        }

        public void GenerateOrderNumber()
        {
            OrderNumber = $"ORD-{CreateAt:yyyyMMddHHmmss}-{UUID.ToString()[..4].ToUpper()}";
        }

        public void CalculateTotalAmount() => TotalAmount = OrderItems.Sum(item => item.TotalPrice);


        public override void Validate()
        {
            base.Validate();
            RuleValidator.Build()
                .When(string.IsNullOrWhiteSpace(OrderNumber), "OrderNumber is required.")
                .When(OrderDate == default, Error.INVALID_DATE)
                .When(TotalAmount < 0, "TotalAmount cannot be negative.")
                .When(string.IsNullOrWhiteSpace(ShippingAddress) || ShippingAddress?.Length > Const.ADDRESS_MAX_LENGTH, Error.INVALID_ADDRESS)
                .When(string.IsNullOrWhiteSpace(BillingAddress) || BillingAddress?.Length > Const.ADDRESS_MAX_LENGTH, Error.INVALID_ADDRESS)
                .When(CreateByUserUuid == Guid.Empty, "CreateByUserUuid is required.")
                .ThrowExceptionIfExists();

            foreach (var item in OrderItems)
            {
                item?.Validate();
            }
        }
    }
}
using SalesOrderManagement.Domain.Entities._bases;
using SalesOrderManagement.Domain.Validations;

namespace SalesOrderManagement.Domain.Entities
{
    public class OrderItem : EntityBase
    {
        public Guid OrderId { get; set; }
        public Order Order { get; set; }

        public Guid ProductId { get; set; }
        public Product Product { get; set; }

        public int Quantity { get; set; }
        public decimal UnitPrice { get; set; }
        public decimal TotalPrice { get; set; }

        public void CalculateTotalPrice() => TotalPrice = UnitPrice * Quantity;


        public override void Validate()
        {
            base.Validate();

            RuleValidator.Build()
                .When(OrderId == Guid.Empty, "OrderId is required.")
                .When(ProductId == Guid.Empty, "ProductId is required.")
                .When(Quantity <= 0, "Quantity must be greater than zero.")
                .When(UnitPrice < 0, "UnitPrice cannot be negative.")
                .When(TotalPrice < 0, "TotalPrice cannot be negative.")
                .When(TotalPrice != Quantity * UnitPrice, "TotalPrice must be equal to Quantity multiplied by UnitPrice.")
                .ThrowExceptionIfExists();

        }
    }
}
using SalesOrderManagement.Domain.Entities._bases;
using SalesOrderManagement.Domain.Errors;
using SalesOrderManagement.Domain.Validations;

namespace SalesOrderManagement.Domain.Entities
{
    public class Product : EntityBase
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public decimal Price { get; set; }
        public int Quantity { get; set; }
        public string Category { get; set; }
        public bool IsActive { get; set; } = true;

        public ICollection<OrderItem> OrderItems { get; set; } = [];


        public override void Validate()
        {
            base.Validate();

            RuleValidator.Build()
                .When(string.IsNullOrWhiteSpace(Name) || Name?.Length > Const.NAME_MAX_LENGTH, Error.INVALID_NAME)
                .When(Price <= 0, Error.INVALID_PRICE)
                .When(Quantity < 0, Error.INVALID_QUANTITY)
                .When(string.IsNullOrWhiteSpace(Category) || Category?.Length > Const.CATEGORY_MAX_LENGTH, "Category is required and cannot exceed maximum length.")
                .ThrowExceptionIfExists();
        }
    }
}
using SalesOrderManagement.Domain.Entities._bases;
using SalesOrderManagement.Domain.Errors;
using SalesOrderManagement.Domain.Validations;
using static SalesOrderManagement.Domain.Entities._bases.Enums;
namespace SalesOrderManagement.Domain.Entities
{
    public class User : EntityBase
    {
        public string FullName { get; set; }
        public string Email { get; set; }
        public string Phone { get; set; }
        public string Password { get; set; }
        public string Document { get; set; }
        public  UserRole UserRole { get; set; }

        public bool IsActive { get; set; } = true;

        public ICollection<Order> CreateByUser { get; set; } = [];
        public ICollection<Order> ActionedOrders { get; set; } = [];



        public override void Validate()
        {
            //InitializeEntity(UUID, CreateAt, Id);

            base.Validate();

            RuleValidator.Build()
                .When(string.IsNullOrWhiteSpace(FullName) || FullName?.Length > Const.NAME_MAX_LENGTH, Error.INVALID_NAME)
                .When(string.IsNullOrWhiteSpace(Email) || !string.IsNullOrWhiteSpace(Email) && !Validations.Rules.IsValidEmail(Email),Error.INVALID_EMAIL)
                .When(string.IsNullOrWhiteSpace(Phone) || !string.IsNullOrWhiteSpace(Phone) && !Validations.Rules.IsValidPhone(Phone),Error.INVALID_PHONE)
                .When(string.IsNullOrWhiteSpace(Password) || !Validations.Rules.IsValidPassword(Password), Error.INVALID_PASSWORD)
                .When(string.IsNullOrWhiteSpace(Document), Error.INVALID_DOCUMENT)
                .ThrowExceptionIfExists();
        }
    }
}
namespace SalesOrderManagement.Domain.Errors
{
    public static class Error
    {
        public const string INVALID_ID = "Invalid ID.";
        public const string INVALID_UUID = "Invalid UUID.";
        public const string INVALID_NAME = "Invalid Name.";
        public const string INVALID_DESCRIPTION = "Invalid Description.";
        public const string INVALID_DATE = "Invalid Date.";
        public const string INVALID_PRICE = "Invalid Price.";
        public const string INVALID_EMAIL = "Invalid E-mail.";
        public const string INVALID_PHONE = "Invalid Phone.";
        public const string INVALID_DOCUMENT = "Invalid Document.";
        public const string INVALID_CATEGORY = "Invalid Category.";
        public const string INVALID_ADDRESS = "Invalid Address.";
        public const string INVALID_QUANTITY = "Invalid Quantity.";
        public const string INVALID_PASSWORD = "Invalid Password.";


        public const string INVALID_LOGIN = "Invalid Login.";
        public const string INVALID_EMAIL_OR_PASSWORD = "Invalid email or password.";

        public const string INVALID_USER = "Invalid User.";
        public const string USER_NOT_FOUND = "User not found.";
        public const string USER_ALREADY_EXISTS = "User already exists.";
        public const string USER_ALREADY_EXISTS_EMAIL = "User with this email already exists.";
        public const string USER_ALREADY_EXISTS_PHONE = "User with this phone already exists.";
        public const string USER_ALREADY_EXISTS_DOCUMENT = "User with this document already exists.";
        public const string USER_NOT_AUTHORIZED = "User not authorized.";
        public const string USER_NOT_ACTIVE = "User not active.";

        public const string PRODUCT_NOT_FOUND = "Product not found.";
        public const string PRODUCT_ALREADY_EXISTS = "Product already exists.";
        public const string PRODUCT_NOT_ACTIVE = "Product not active.";
        public const string ORDER_NOT_FOUND = "Order not found.";
        public const string ORDER_ITEM_NOT_FOUND = "Order item not found.";
        public const string ORDER_ITEM_ALREADY_EXISTS = "Order item already exists.";
        public const string ORDER_ITEM_NOT_ACTIVE = "Order item not active.";
        public const string ORDER_ALREADY_EXISTS = "Order already exists.";
        public const string ORDER_NOT_ACTIVE = "Order not active.";
        public const string ORDER_ITEM_NOT_BELONG_TO_ORDER = "Order item does not belong to the order.";
        public const string ORDER_ITEM_NOT_BELONG_TO_PRODUCT = "Order item does not belong to the product.";
        public const string ORDER_ITEM_QUANTITY_NOT_AVAILABLE = "Order item quantity not available.";
        public const string ORDER_ITEM_QUANTITY_NOT_VALID = "Order item quantity not valid.";
        public const string ORDER_ITEM_QUANTITY_NOT_VALID_FOR_PRODUCT = "Order item quantity not valid for product.";
        public const string ORDER_ITEM_QUANTITY_NOT_VALID_FOR_ORDER = "Order item quantity not valid for order.";
        public const string ORDER_ITEM_QUANTITY_NOT_VALID_FOR_ORDER_ITEM = "Order item quantity not valid for order item.";


        public const string UNEXPECTED_ERROR = "An unexpected error occurred.";
        public const string UNAUTHORIZED = "Unauthorized.";


    }
}
namespace SalesOrderManagement.Domain.Validations
{
    public class DomainExceptionValidation : ArgumentException
    {
        internal string Error { get; set; }

        internal DomainExceptionValidation(string error) : base(error) => Error = error;

    }
}
using System.Text.RegularExpressions;

namespace SalesOrderManagement.Domain.Validations
{
    public static partial class Rules
    {
        public static bool IsValidEmail(string email)
        {
            if (string.IsNullOrWhiteSpace(email))
                return false;

            return EmailRegex().IsMatch(email);
        }

        public static bool IsValidPhone(string phone)
        {
            if (string.IsNullOrWhiteSpace(phone))
                return false;

            return PhoneNumberRegex().IsMatch(phone);
        }
        public static bool IsValidPassword(string password)
        {
            if (string.IsNullOrEmpty(password))
            {
                return false;
            }

            string passwordRegex = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+=\\[\\]{};':\"\\\\|,.<>\\/?]).{8,}$";
            return Regex.IsMatch(password, passwordRegex);
        }


        [GeneratedRegex(@"^(\d{2,3}|\(\d{2,3}\))?\s?\d{4,5}-?\d{4}$")]
        private static partial Regex PhoneNumberRegex();
        [GeneratedRegex(@"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$")]
        private static partial Regex EmailRegex();

       
    }
}
namespace SalesOrderManagement.Domain.Validations
{
    public class RuleValidator
    {
        private List<string> _errorList;
        private string _message;

        private RuleValidator() => _errorList = [];

        internal static RuleValidator Build() => new();


        internal RuleValidator When(bool haserror, string error)
        {
            if (haserror)
            {
                _errorList.Add(error);
            }
            return this;
        }
        internal void ThrowExceptionIfExists()
        {
            if (_errorList.Count > 0)
            {
                _message = string.Join(", ", _errorList);
                _message += ".";

                throw new DomainExceptionValidation(_message);
            }
        }


    }
}
Interfaces
using SalesOrderManagement.Domain.Entities._bases;

namespace SalesOrderManagement.Domain.Interfaces._bases
{
    public interface IRepositoryBase<T> where T : EntityBase
    {
        Task<Guid> Add(T entity);
        Task<bool> Delete(int id);
        Task<bool> Delete(Guid uuid);
        Task<T> Get(int id);
        Task<T> Get(Guid uuid);
        Task<bool> Update(T entity);
    }
}
using SalesOrderManagement.Domain.Entities;
using SalesOrderManagement.Domain.Interfaces._bases;

namespace SalesOrderManagement.Domain.Interfaces.Repositories
{
    public interface IOrderItemRepository : IRepositoryBase<OrderItem>
    {
        Task<IEnumerable<OrderItem>> GetOrderItemsByOrderId(Guid orderId);
        Task<OrderItem> GetOrderItemByProductId(Guid productId);
        Task<OrderItem> GetOrderItemWithProduct(Guid uuid);
        Task<IEnumerable<OrderItem>> GetAllWithProductAsync();


    }

}
using SalesOrderManagement.Domain.Entities;
using SalesOrderManagement.Domain.Interfaces._bases;
using static SalesOrderManagement.Domain.Entities._bases.Enums;

namespace SalesOrderManagement.Domain.Interfaces.Repositories
{
    public interface IOrderRepository: IRepositoryBase<Order>
    {
        Task<IEnumerable<Order>> GetOrdersByUserId(Guid userId);
        Task<IEnumerable<Order>> GetOrdersByStatus(OrderStatus status);
        Task<IEnumerable<Order>> GetOrdersByDateRange(DateTime startDate, DateTime endDate);

        Task<Order> GetOrderWithOrdemItems(Guid uuid);
        Task<IEnumerable<Order>> GetAllWithItemsAsync();

    }
}
using SalesOrderManagement.Domain.Entities;
using SalesOrderManagement.Domain.Interfaces._bases;

namespace SalesOrderManagement.Domain.Interfaces.Repositories
{
    public interface IProductRepository : IRepositoryBase<Product>
    {
        public Task<IEnumerable<Product>> GetAll();
        public Task<IEnumerable<Product>> GetAllByCategory(string category);


    }
}
using SalesOrderManagement.Domain.Entities;
using SalesOrderManagement.Domain.Interfaces._bases;
using static SalesOrderManagement.Domain.Entities._bases.Enums;

namespace SalesOrderManagement.Domain.Interfaces.Repositories
{
    public interface IUserRepository : IRepositoryBase<User>
    {
        Task<User> GetByEmail(string email);
        Task<User> GetByDocument(string document);
        Task<User> GetByPhone(string phone);
        Task<IEnumerable<User>> GetAll();
        Task<IEnumerable<User>> GetAllByRole(UserRole role);

    }
}


Terminou a camada de dominio

Camada compartilhada 
using System.Net;
using System.Reflection.Metadata;

namespace SharedKernel.Utils
{
    public class ApiResponse<T>
    {
        public bool Success { get; set; }
        public string? Message { get; set; }
        public T? Data { get; set; }
        public int? ErrorCode { get; set; }
        public List<string>? Errors { get; set; }

        public ApiResponse<T> Sucess(T data, string? message = null)
        {

            Success = true;
            Data = data;
            Message = message;
            return this;
        }

        public ApiResponse<T> Failure(T? data, int? errorCode = null, string? message = null, Exception? exception = null, List<string>? errors = null)
        {
            if (exception is not null)
            {
                //message = exception.StackTrace;
                message = exception.Message;
            }
            Success = false;
            ErrorCode = errorCode;
            Message = message;
            Data = data;
            Errors = errors;
            return this;
        }

    }
    public class Response<T>
    {
        public HttpStatusCode StatusCode { get; set; }
        public ApiResponse<T> ApiReponse { get; set; } = new ApiResponse<T>();

        public Response<T> Sucess(T data, string? message = null, HttpStatusCode? statusCode = null)
        {
            message = message is not null ? message : "System success";
            StatusCode = statusCode is null ? HttpStatusCode.OK : statusCode.Value;
            ApiReponse = new ApiResponse<T>().Sucess(data, message);
            return this;
        }
        public Response<T> Failure(T? data, int? errorCode = null, string? message = null, Exception? exception = null, List<string>? errors = null, HttpStatusCode? statusCode = null)
        {
            StatusCode = statusCode is null ? HttpStatusCode.BadRequest : statusCode.Value;
            ApiReponse = new ApiResponse<T>().Failure(data, errorCode, message, exception, errors);
            return this;
        }
    }

}

Fim da camada Compartilhada 
Camada de applicação
Dtos
namespace SalesOrderManagement.Application.Dtos.Auth
{
    public class AuthenticationResponse
    {
        public string AccessToken { get; set; }
        public int ExpiresIn { get; set; }
    }
}
public class ActiveCustomerDto
{
    public Guid CustomerId { get; set; }
    public string CustomerName { get; set; } 
    public int OrderCount { get; set; }
}
public class DashboardReportDto
{
    public SalesSummaryDto SalesSummary { get; set; }
    public int PendingOrdersCount { get; set; }
    public List<ActiveCustomerDto> MostActiveCustomers { get; set; }
}
using Mapster;
using SalesOrderManagement.Application.Dtos.Entities.Order;
using SalesOrderManagement.Application.Dtos.Entities.OrderItem;
using SalesOrderManagement.Application.Interfaces.Business;
using SalesOrderManagement.Application.Interfaces.UseCases;
using SharedKernel.Utils;
using System.Net;

namespace SalesOrderManagement.Application.Dtos.Dashboard
{
    public class OrderProcessing : IOrderProcessing
    {
        private readonly IOrderBusiness _orderBusiness;
        private readonly IProductBusiness _productBusiness;
        private readonly IOrderItemBusiness _orderItemBusiness;

        public OrderProcessing(IOrderBusiness orderBusiness, IProductBusiness productBusiness, IOrderItemBusiness orderItemBusiness)
        {
            _orderBusiness = orderBusiness;
            _productBusiness = productBusiness;
            _orderItemBusiness = orderItemBusiness;
        }

        public async Task<Response<Guid>> CreateOrder(CreateOrderDto createOrderDto)
        {
            try
            {
                var orderResult = await _orderBusiness.Add(createOrderDto);
                if (!orderResult.ApiReponse.Success)
                {
                    return new Response<Guid>().Failure(default, message: orderResult.ApiReponse.Message, statusCode: orderResult.StatusCode);
                }
                var orderUuid = orderResult.ApiReponse.Data;
                var orderEntityResult = await _orderBusiness.GetEntity(orderUuid);
                if (!orderEntityResult.ApiReponse.Success || orderEntityResult.ApiReponse.Data == null)
                {
                    return new Response<Guid>().Failure(default, message: "Erro ao recuperar a entidade do pedido.", statusCode: HttpStatusCode.InternalServerError);
                }
                var orderEntity = orderEntityResult.ApiReponse.Data;
                await _orderBusiness.Update(orderEntity.Adapt<UpdateOrderDto>());

                decimal totalOrderAmount = 0;
                var createdOrderItemsUuids = new List<Guid>();


                foreach (var itemDto in createOrderDto.OrderItems)
                {
                    var productResult = await _productBusiness.GetEntity(itemDto.ProductId);
                    if (!productResult.ApiReponse.Success || productResult.ApiReponse.Data == null)
                    {
                        return new Response<Guid>().Failure(default, message: $"Produto com UUID: {itemDto.ProductId} não encontrado.", statusCode: HttpStatusCode.NotFound);
                    }
                    var product = productResult.ApiReponse.Data;

                    var createOrderItemResult = await _orderItemBusiness.Add(itemDto);
                    if (!createOrderItemResult.ApiReponse.Success)
                    {

                        return new Response<Guid>().Failure(default, message: $"Erro ao adicionar item ao pedido: {createOrderItemResult.ApiReponse.Message}", statusCode: createOrderItemResult.StatusCode);
                    }
                    var orderItemUuid = createOrderItemResult.ApiReponse.Data;
                    var orderItemEntityResult = await _orderItemBusiness.GetEntity(orderItemUuid);
                    if (!orderItemEntityResult.ApiReponse.Success || orderItemEntityResult.ApiReponse.Data == null)
                    {
                        return new Response<Guid>().Failure(default, message: "Erro ao recuperar a entidade do item do pedido.", statusCode: HttpStatusCode.InternalServerError);
                    }
                    var orderItemEntity = orderItemEntityResult.ApiReponse.Data;
                    orderItemEntity.OrderId = orderEntity.UUID;
                    orderItemEntity.UnitPrice = product.Price;
                    orderItemEntity.TotalPrice = orderItemEntity.UnitPrice * orderItemEntity.Quantity;
                    await _orderItemBusiness.Update(orderItemEntity.Adapt<UpdateOrderItemDto>());

                    totalOrderAmount += orderItemEntity.TotalPrice;
                    createdOrderItemsUuids.Add(orderItemUuid);
                }

                orderEntity.TotalAmount = totalOrderAmount;
                await _orderBusiness.Update(orderEntity.Adapt<UpdateOrderDto>());

                return new Response<Guid>().Sucess(orderUuid, message: "Pedido criado com sucesso.", statusCode: HttpStatusCode.Created);
            }
            catch (Exception ex)
            {
                return new Response<Guid>().Failure(default, message: $"Erro ao processar a criação do pedido: {ex.Message}", statusCode: HttpStatusCode.InternalServerError);
            }
        }
    }
}
public class SalesSummaryDto
{
    public int TotalOrders { get; set; }
    public decimal TotalRevenue { get; set; }
    public int TotalProductsSold { get; set; }
}
using SalesOrderManagement.Application.Dtos.Entities.OrderItem;
using SalesOrderManagement.Domain.Entities._bases;
using SalesOrderManagement.Domain.Errors;
using System.ComponentModel.DataAnnotations;
using static SalesOrderManagement.Domain.Entities._bases.Enums;
namespace SalesOrderManagement.Application.Dtos.Entities.Order
{
    public class CreateOrderDto
    {
        public DateTime? OrderDate { get; set; }

        [Required(ErrorMessage = Error.INVALID_ADDRESS)]
        [MaxLength(Const.ADDRESS_MAX_LENGTH, ErrorMessage = "O endereço de entrega não pode exceder 255 caracteres.")]
        public string ShippingAddress { get; set; }

        [Required(ErrorMessage = Error.INVALID_ADDRESS)]
        [MaxLength(Const.ADDRESS_MAX_LENGTH, ErrorMessage = "O endereço de cobrança não pode exceder 255 caracteres.")]
        public string BillingAddress { get; set; }

        [Required(ErrorMessage = "O método de pagamento é obrigatório.")]
        public PaymentMethod PaymentMethod { get; set; }

        public Guid? CreateByUserUuid { get; set; }

        [Required(ErrorMessage = "Os itens do pedido são obrigatórios.")]
        public List<CreateOrderItemDto> OrderItems { get; set; }
    }
}

using SalesOrderManagement.Application.Dtos.Entities.OrderItem;
using static global::SalesOrderManagement.Domain.Entities._bases.Enums;

namespace SalesOrderManagement.Application.Dtos.Entities.Order
{
    public class OrderDto
    {
        public Guid UUID { get; set; }
        public string OrderNumber { get; set; }
        public DateTime OrderDate { get; set; }
        public decimal TotalAmount { get; set; }
        public string ShippingAddress { get; set; }
        public string BillingAddress { get; set; }
        public PaymentMethod PaymentMethod { get; set; }
        public OrderStatus Status { get; set; }
        public Guid CreateByUserUuid { get; set; }
        public Guid? ActionedByUserUuid { get; set; }
        public DateTime? ActionedAt { get; set; }
        public ICollection<OrderItemDto> OrderItems { get; set; }
    }
}
using SalesOrderManagement.Application.Dtos.Entities.OrderItem;
using SalesOrderManagement.Domain.Entities._bases;
using SalesOrderManagement.Domain.Errors;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using static SalesOrderManagement.Domain.Entities._bases.Enums;

namespace SalesOrderManagement.Application.Dtos.Entities.Order
{
    public class UpdateOrderDto
    {
        [Required(ErrorMessage = Error.INVALID_UUID)]
        public Guid UUID { get; set; }

        public DateTime? OrderDate { get; set; }

        [MaxLength(Const.ADDRESS_MAX_LENGTH, ErrorMessage = "O endereço de entrega não pode exceder 255 caracteres.")]
        public string ShippingAddress { get; set; }

        [MaxLength(Const.ADDRESS_MAX_LENGTH, ErrorMessage = "O endereço de cobrança não pode exceder 255 caracteres.")]
        public string BillingAddress { get; set; }

        public PaymentMethod? PaymentMethod { get; set; }

        public OrderStatus? Status { get; set; }

        public Guid? ActionedByUserUuid { get; set; }

        public ICollection<UpdateOrderItemDto> OrderItems { get; set; }
    }
}
using SalesOrderManagement.Domain.Errors;
using System.ComponentModel.DataAnnotations;
namespace SalesOrderManagement.Application.Dtos.Entities.OrderItem
{
    public class CreateOrderItemDto
    {
        [Required(ErrorMessage = $"Product {Error.INVALID_UUID} ")]
        public Guid ProductId { get; set; }


        [Required(ErrorMessage = $"Order {Error.INVALID_UUID} ")]
        public Guid OrderId { get; set; }

        [Required(ErrorMessage = Error.INVALID_QUANTITY)]
        [Range(1, int.MaxValue, ErrorMessage = "A quantidade deve ser maior que zero.")]
        public int Quantity { get; set; }

    }
}

namespace SalesOrderManagement.Application.Dtos.Entities.OrderItem
{
    public class OrderItemDto
    {
        public Guid UUID { get; set; }
        public Guid ProductId { get; set; }
        public int Quantity { get; set; }
        public decimal UnitPrice { get; set; }
        public decimal TotalPrice { get; set; }
    }
}
using SalesOrderManagement.Domain.Errors;
using System.ComponentModel.DataAnnotations;

namespace SalesOrderManagement.Application.Dtos.Entities.OrderItem
{
    public class UpdateOrderItemDto
    {
        [Required(ErrorMessage = Error.INVALID_UUID)]
        public Guid UUID { get; set; }

        [Required(ErrorMessage = "O UUID do produto é obrigatório.")]
        public Guid ProductId { get; set; }        
        
        [Required(ErrorMessage = "O UUID do produto é obrigatório.")]
        public Guid OrderId { get; set; }

        [Required(ErrorMessage = "A quantidade é obrigatória.")]
        [Range(1, int.MaxValue, ErrorMessage = "A quantidade deve ser maior que zero.")]
        public int Quantity { get; set; }
    }
}
using SalesOrderManagement.Domain.Entities._bases;
using SalesOrderManagement.Domain.Errors;
using System.ComponentModel.DataAnnotations;

namespace SalesOrderManagement.Application.Dtos.Entities.Product
{
    public class CreateProductDto
    {
        [Required(ErrorMessage = Error.INVALID_NAME)]
        [MaxLength(Const.NAME_MAX_LENGTH, ErrorMessage = "O nome do produto não pode exceder 255 caracteres.")]
        public string Name { get; set; }

        [MaxLength(Const.DESCRIPTION_MAX_LENGTH, ErrorMessage = "A descrição do produto não pode exceder 1000 caracteres.")]
        public string Description { get; set; }

        [Required(ErrorMessage = "O preço do produto é obrigatório.")]
        [Range(0.01, double.MaxValue, ErrorMessage = "O preço do produto deve ser maior que zero.")]
        public decimal Price { get; set; }

        [Required(ErrorMessage = "A quantidade do produto é obrigatória.")]
        [Range(0, int.MaxValue, ErrorMessage = "A quantidade do produto não pode ser negativa.")]
        public int Quantity { get; set; }

        [Required(ErrorMessage = "A categoria do produto é obrigatória.")]
        [MaxLength(Const.CATEGORY_MAX_LENGTH, ErrorMessage = "A categoria do produto não pode exceder 100 caracteres.")]
        public string Category { get; set; }

    }
}
namespace SalesOrderManagement.Application.Dtos.Entities.Product
{
    public class ProductDto
    {
        public Guid UUID { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }
        public decimal Price { get; set; }
        public int Quantity { get; set; }
        public string Category { get; set; }
        public bool IsActive { get; set; }
    }
}
using SalesOrderManagement.Domain.Entities._bases;
using SalesOrderManagement.Domain.Errors;
using System.ComponentModel.DataAnnotations;

namespace SalesOrderManagement.Application.Dtos.Entities.Product
{
    public class UpdateProductDto
    {
        [Required(ErrorMessage = Error.INVALID_UUID)]
        public Guid UUID { get; set; }

        [MaxLength(Const.NAME_MAX_LENGTH, ErrorMessage = "O nome do produto não pode exceder 255 caracteres.")]
        public string Name { get; set; }

        [MaxLength(Const.DESCRIPTION_MAX_LENGTH, ErrorMessage = "A descrição do produto não pode exceder 1000 caracteres.")]
        public string Description { get; set; }

        [Range(0.01, double.MaxValue, ErrorMessage = "O preço do produto deve ser maior que zero.")]
        public decimal? Price { get; set; } 

        [Range(0, int.MaxValue, ErrorMessage = "A quantidade do produto não pode ser negativa.")]
        public int? Quantity { get; set; } 

        [MaxLength(Const.CATEGORY_MAX_LENGTH, ErrorMessage = "A categoria do produto não pode exceder 100 caracteres.")]
        public string Category { get; set; }

        public bool? IsActive { get; set; } 
    }
}
using System.ComponentModel.DataAnnotations;

namespace SalesOrderManagement.Application.Dtos.Entities.User
{
    public class ChangePasswordDto
    {
        [Required(ErrorMessage = "O UUID do usuário é obrigatório.")]
        public Guid UUID { get; set; }

        [Required(ErrorMessage = "A senha antiga é obrigatória.")]
        public string OldPassword { get; set; }

        [Required(ErrorMessage = "A nova senha é obrigatória.")]
        [MinLength(8, ErrorMessage = "A nova senha deve ter pelo menos 8 caracteres.")]
        // Podemos adicionar aqui outras validações de força de senha, se necessário (ex: Regex)
        public string NewPassword { get; set; }

        [Required(ErrorMessage = "A confirmação da nova senha é obrigatória.")]
        [Compare("NewPassword", ErrorMessage = "A nova senha e a confirmação não coincidem.")]
        public string ConfirmNewPassword { get; set; }
    }
}
using SalesOrderManagement.Domain.Entities._bases;
using System.ComponentModel.DataAnnotations;
using static SalesOrderManagement.Domain.Entities._bases.Enums;

namespace SalesOrderManagement.Application.Dtos.Entities.User
{
    public class CreateUserDto
    {
        [Required(ErrorMessage = "O Nome Completo é obrigatório.")]
        [MaxLength(Const.NAME_MAX_LENGTH, ErrorMessage = "O Nome Completo não pode exceder 255 caracteres.")]
        public string FullName { get; set; }

        [Required(ErrorMessage = "O Email é obrigatório.")]
        [EmailAddress(ErrorMessage = "O Email não é válido.")]
        [MaxLength(Const.EMAIL_MAX_LENGTH, ErrorMessage = "O Email não pode exceder 255 caracteres.")]
        public string Email { get; set; }

        [MaxLength(Const.PHONE_MAX_LENGTH, ErrorMessage = "O Telefone não pode exceder 20 caracteres.")]
        public string? Phone { get; set; }

        [Required(ErrorMessage = "A Senha é obrigatória.")]
        public string Password { get; set; }

        [MaxLength(Const.DOCUMENT_MAX_LENGTH, ErrorMessage = "O Documento não pode exceder 18 caracteres.")]
        public string? Document { get; set; }

        [Required(ErrorMessage = "O Tipo de Usuário é obrigatório.")]
        [EnumDataType(typeof(UserRole), ErrorMessage = "O Tipo de Usuário não é válido.")]
        public UserRole UserRole { get; set; }
    }
}
using SalesOrderManagement.Domain.Entities._bases;
using System.ComponentModel.DataAnnotations;
using static SalesOrderManagement.Domain.Entities._bases.Enums;

namespace SalesOrderManagement.Application.Dtos.Entities.User
{
    public class UpdateUserDto
    {
        [Required(ErrorMessage = "O UUID do usuário a ser atualizado é obrigatório.")]
        public Guid UUID { get; set; }

        [MaxLength(Const.NAME_MAX_LENGTH, ErrorMessage = "O Nome Completo não pode exceder 255 caracteres.")]
        public string? FullName { get; set; }

        [EmailAddress(ErrorMessage = "O Email não é válido.")]
        [MaxLength(Const.EMAIL_MAX_LENGTH, ErrorMessage = "O Email não pode exceder 255 caracteres.")]
        public string? Email { get; set; }

        [MaxLength(Const.PHONE_MAX_LENGTH, ErrorMessage = "O Telefone não pode exceder 20 caracteres.")]
        public string? Phone { get; set; }

        [MaxLength(Const.DOCUMENT_MAX_LENGTH, ErrorMessage = "O Documento não pode exceder 18 caracteres.")]
        public string? Document { get; set; }

        [EnumDataType(typeof(UserRole), ErrorMessage = "O Tipo de Usuário não é válido.")]
        public UserRole? UserRole { get; set; }

        public bool? IsActive { get; set; }
    }
}
using static SalesOrderManagement.Domain.Entities._bases.Enums;

namespace SalesOrderManagement.Application.Dtos.Entities.User
{
    public class UserDto
    {
        public Guid UUID { get; set; }
        public string FullName { get; set; }
        public string Email { get; set; }
        public string? Phone { get; set; }
        public string? Document { get; set; }
        public UserRole UserRole { get; set; }
        public bool IsActive { get; set; }
    }
}
Interfaces da aplicação
using SalesOrderManagement.Domain.Entities._bases;
using SharedKernel.Utils;

namespace SalesOrderManagement.Application.Interfaces.Business._bases
{
    public interface IBusinessBase<T, TCreateDto, TUpdateDto, TGetDto> where T : EntityBase
    {
        Task<Response<Guid>> Add(TCreateDto dto);
        Task<Response<bool>> Delete(int id);
        Task<Response<bool>> Delete(Guid guid);
        Task<Response<TGetDto>> Get(int id);
        Task<Response<TGetDto>> GetDto(Guid guid);
        Task<Response<T>> GetEntity(Guid guid);
        Task<Response<bool>> Update(TUpdateDto dto);
    }
}
using SalesOrderManagement.Application.Dtos.Entities.Order;
using SalesOrderManagement.Application.Interfaces.Business._bases;
using SalesOrderManagement.Domain.Entities;
using SharedKernel.Utils;

namespace SalesOrderManagement.Application.Interfaces.Business
{
    public interface IOrderBusiness : IBusinessBase<Order, CreateOrderDto, UpdateOrderDto, OrderDto>
    {
        Task<Response<IEnumerable<OrderDto>>> GetOrdersByUserId(Guid userId);
        Task<Response<IEnumerable<OrderDto>>> GetOrdersByStatus(string status);
        Task<Response<IEnumerable<OrderDto>>> GetOrdersByDateRange(DateTime startDate, DateTime endDate);
        Task<Response<OrderDto>> GetOrderWithOrdemItems(Guid uuid);
        Task<Response<IEnumerable<OrderDto>>> GetAllWithItemsAsync();

    }
}
using SalesOrderManagement.Application.Dtos.Entities.OrderItem;
using SalesOrderManagement.Application.Interfaces.Business._bases;
using SalesOrderManagement.Domain.Entities;
using SharedKernel.Utils;

namespace SalesOrderManagement.Application.Interfaces.Business
{
    public interface IOrderItemBusiness : IBusinessBase<OrderItem, CreateOrderItemDto, UpdateOrderItemDto, OrderItemDto>
    {
        Task<Response<IEnumerable<OrderItemDto>>> GetOrderItemsByOrderId(Guid orderId);

    }
}
using SalesOrderManagement.Application.Dtos.Entities.Product;
using SalesOrderManagement.Application.Interfaces.Business._bases;
using SalesOrderManagement.Domain.Entities;
using SharedKernel.Utils;

namespace SalesOrderManagement.Application.Interfaces.Business
{
    public interface IProductBusiness : IBusinessBase<Product, CreateProductDto, UpdateProductDto, ProductDto>
    {
        Task<Response<IEnumerable<ProductDto>>> GetAll();
        Task<Response<IEnumerable<ProductDto>>> GetAllByCategory(string category);
    }
}
using SalesOrderManagement.Application.Dtos.Entities.User;
using SalesOrderManagement.Application.Interfaces.Business._bases;
using SalesOrderManagement.Domain.Entities;
using SharedKernel.Utils;

namespace SalesOrderManagement.Application.Interfaces.Business
{
    public interface IUserBusiness : IBusinessBase<User, CreateUserDto, UpdateUserDto, UserDto>
    {
        Task<Response<User>> Get(string email);
        Task<Response<bool>> ChangePasswordAsync(ChangePasswordDto changePasswordDto);
        Task<Response<IEnumerable<UserDto>>> GetAll();
        Task<Response<IEnumerable<UserDto>>> GetAllByRole(string role);

    }
}
using SharedKernel.Utils;

namespace SalesOrderManagement.Application.Interfaces.UseCases
{
    public interface IDashboard
    {
        Task<Response<SalesSummaryDto>> GetSalesSummary();
        Task<Response<int>> GetPendingOrdersCount();
        Task<Response<List<ActiveCustomerDto>>> GetMostActiveCustomers();
    }
}
using SalesOrderManagement.Application.Dtos.Entities.Order;
using SalesOrderManagement.Application.Dtos.Entities.OrderItem;
using SharedKernel.Utils;

namespace SalesOrderManagement.Application.Interfaces.UseCases
{
    public interface IOrderProcessing
    {
        Task<Response<Guid>> CreateOrder(CreateOrderDto createOrderDto);
    }
}
using SalesOrderManagement.Application.Dtos.Auth;
using SharedKernel.Utils;

namespace SalesOrderManagement.Application.Interfaces.UseCases
{
    public interface IUserAuthentication
    {
        Task<Response<AuthenticationResponse>> Login(string email, string password);

    }
}
using SalesOrderManagement.Application.Authentication;
using SalesOrderManagement.Application.Dtos.Auth;


namespace SalesOrderManagement.Application.Interfaces
{
    public interface ITokenService
    {
        Task<AuthenticationResponse> GenerateJwtToken(UserAuthenticateJWT userAuthenticateJwt);
        int GetTokenLifetimeInMinutes();
    }
}
Configuração do mapster
using Mapster;
using SalesOrderManagement.Application.Dtos.Entities.Order;
using SalesOrderManagement.Application.Dtos.Entities.OrderItem;
using SalesOrderManagement.Application.Dtos.Entities.Product;
using SalesOrderManagement.Application.Dtos.Entities.User;
using SalesOrderManagement.Domain.Entities;
using static SalesOrderManagement.Domain.Entities._bases.Enums;


namespace SalesOrderManagement.Application.Profiles
{
    public class MapsterConfiguration
    {
        public static void Configure()
        {
            #region User
            TypeAdapterConfig<UserDto, User>.NewConfig().TwoWays();

            TypeAdapterConfig<CreateUserDto, User>.NewConfig()
                .Map(dest => dest.FullName, src => src.FullName.Trim())
                .Map(dest => dest.IsActive, src => true)
                .Map(dest => dest.CreateAt, src => DateTime.UtcNow)
                .Map(dest => dest.UUID, src => Guid.CreateVersion7());

            TypeAdapterConfig<UpdateUserDto, User>.NewConfig()
                .Ignore(dest => dest.Id)
                .Ignore(dest => dest.CreateAt)
                .Map(dest => dest.UpdateAt, src => DateTime.UtcNow);

            #endregion

            #region Product
            TypeAdapterConfig<Product, ProductDto>.NewConfig().TwoWays();

            TypeAdapterConfig<CreateProductDto, Product>.NewConfig()
                .Map(dest => dest.Name, src => src.Name.Trim())
                .Map(dest => dest.Description, src => src.Description.Trim())
                .Map(dest => dest.IsActive, src => true)
                .Map(dest => dest.CreateAt, src => DateTime.UtcNow)
                .Map(dest => dest.UUID, src => Guid.CreateVersion7());


            TypeAdapterConfig<UpdateProductDto, Product>.NewConfig()
                .Ignore(dest => dest.Id)
                .Ignore(dest => dest.CreateAt)
                .Map(dest => dest.UpdateAt, src => DateTime.UtcNow);
            #endregion

            #region Order
            TypeAdapterConfig<Order, OrderDto>.NewConfig().TwoWays();

            TypeAdapterConfig<CreateOrderDto, Order>.NewConfig()
                .Map(dest => dest.OrderDate, src => DateTime.UtcNow)
                .Map(dest => dest.ShippingAddress, src => src.ShippingAddress.Trim())
                .Map(dest => dest.BillingAddress, src => src.BillingAddress.Trim())
                .Map(dest => dest.CreateAt, src => DateTime.UtcNow)
                .Map(dest => dest.Status, src => OrderStatus.Pending)
                .Map(dest => dest.UUID, src => Guid.CreateVersion7());


            TypeAdapterConfig<UpdateOrderDto, Order>.NewConfig()
                .Ignore(dest => dest.Id)
                .Ignore(dest => dest.CreateAt)
                .Map(dest => dest.UpdateAt, src => DateTime.UtcNow)
                .Map(dest => dest.ShippingAddress, src => src.ShippingAddress.Trim())
                .Map(dest => dest.BillingAddress, src => src.BillingAddress.Trim());
            #endregion

            #region OrderItem
            TypeAdapterConfig<OrderItem, OrderItemDto>.NewConfig().TwoWays();

            TypeAdapterConfig<CreateOrderItemDto, OrderItem>.NewConfig()
                .Map(dest => dest.CreateAt, src => DateTime.UtcNow)
                .Map(dest => dest.UUID, src => Guid.CreateVersion7());

            TypeAdapterConfig<UpdateOrderItemDto, OrderItem>.NewConfig()
                .Ignore(dest => dest.Id)
                .Ignore(dest => dest.CreateAt)
                .Map(dest => dest.UpdateAt, src => DateTime.UtcNow);

            #endregion
        }
    }
}
using DotNetEnv;
using Microsoft.Extensions.Configuration;
using Microsoft.IdentityModel.Tokens;
using SalesOrderManagement.Application.Authentication;
using SalesOrderManagement.Application.Dtos.Auth;
using SalesOrderManagement.Application.Interfaces;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

namespace SalesOrderManagement.Application.Services
{
    public class TokenBusiness : ITokenService
    {
        private readonly IConfiguration _configuration;
        private readonly string _jwtKey;

        public TokenBusiness(IConfiguration configuration)
        {
            _configuration = configuration;
            //Env.TraversePath().Load();
            string getToken = Environment.GetEnvironmentVariable("TOKEN_JWT_SECRET");
            if (string.IsNullOrEmpty(getToken))
            {
                getToken = configuration["Jwt:Key"];
            }
            _jwtKey = getToken;
        }

        public async Task<AuthenticationResponse> GenerateJwtToken(UserAuthenticateJWT userAuthenticateJwt)
        {
            AuthenticationResponse authenticationResponse = new();
            var claims = new ClaimsIdentity(
            [
                new(ClaimTypes.NameIdentifier, userAuthenticateJwt.UserUuid.ToString()),
                new(ClaimTypes.Email, userAuthenticateJwt.UserEmail),
                new(ClaimTypes.Name, userAuthenticateJwt.UserName),
                new(ClaimTypes.Role, userAuthenticateJwt.UserRole),

            ]);

            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtKey));
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
            var expiry = DateTime.UtcNow.AddMinutes(GetTokenLifetimeInMinutes());

            var token = new SecurityTokenDescriptor()
            {
                Issuer = _configuration["Jwt:Issuer"],
                Audience = _configuration["Jwt:Audience"],

                Subject = claims,
                Expires = expiry,
                SigningCredentials = creds
            };
            var handler = new JwtSecurityTokenHandler();
            var tokenCreate = handler.CreateToken(token);
            authenticationResponse.AccessToken = handler.WriteToken(tokenCreate);
            authenticationResponse.ExpiresIn = (int)expiry.Subtract(DateTime.UtcNow).TotalMinutes;
            return authenticationResponse;
        }

        public int GetTokenLifetimeInMinutes()
        {
            var tokenLifetime = _configuration["Jwt:TokenLifetimeMinutes"];
            if (int.TryParse(tokenLifetime, out int tokenLifetimeMinutes))
            {
                return tokenLifetimeMinutes;
            }
            return 120;
        }
    }
}
using Microsoft.Extensions.Logging;
using SalesOrderManagement.Application.Interfaces.Business;
using SalesOrderManagement.Application.Interfaces.UseCases;
using SalesOrderManagement.Domain.Entities._bases;
using SharedKernel.Utils;
using System.Net;
using static SalesOrderManagement.Domain.Entities._bases.Enums;

namespace SalesOrderManagement.Application.UseCases
{
    public class Dashboard(IOrderBusiness orderBusiness, IOrderItemBusiness orderItemBusiness, 
                                 ILogger<Dashboard> logger, IProductBusiness productBusiness, IUserBusiness userBusiness) : IDashboard
    {
        private readonly IOrderBusiness _orderBusiness = orderBusiness;
        private readonly IOrderItemBusiness _orderItemBusiness = orderItemBusiness;
        private readonly ILogger<Dashboard> _logger = logger;
        private readonly IProductBusiness _productBusiness = productBusiness;
        private readonly IUserBusiness _userBusiness = userBusiness; 

        public async Task<Response<DashboardReportDto>> GetDashboardReport()
        {
            try
            {
                var allOrdersResponse = await _orderBusiness.GetAllWithItemsAsync();
                if (!allOrdersResponse.ApiReponse.Success || allOrdersResponse.ApiReponse.Data == null)
                {
                    _logger.LogError("Erro ao obter todos os pedidos para o dashboard.");
                    return new Response<DashboardReportDto>().Failure(default, message: "Erro ao obter dados de pedidos.", statusCode: HttpStatusCode.InternalServerError);
                }
                var allOrders = allOrdersResponse.ApiReponse.Data.ToList();

                // Resumo de Vendas
                var totalOrders = allOrders.Count;
                var totalRevenue = allOrders.Sum(o => o.TotalAmount);
                var totalProductsSold = allOrders.Sum(o => o.OrderItems?.Sum(oi => oi.Quantity) ?? 0);

                var salesSummary = new SalesSummaryDto
                {
                    TotalOrders = totalOrders,
                    TotalRevenue = totalRevenue,
                    TotalProductsSold = totalProductsSold
                };

                // Pedidos Pendentes
                var pendingOrdersCount = allOrders.Count(o => o.Status == Enums.OrderStatus.Pending);

                // Clientes Mais Ativos (Exemplo básico - pode precisar de mais informações do cliente)
                var customerOrderCounts = allOrders
                    .GroupBy(o => o.CreateByUserUuid)
                    .Select(g => new { CustomerId = g.Key, OrderCount = g.Count() })
                    .OrderByDescending(c => c.OrderCount)
                    .Take(5); // Pegar os 5 clientes mais ativos

                var activeCustomers = new List<ActiveCustomerDto>();
                // Assuming you have a way to get customer names by their UUID (e.g., from a customer business)
                foreach (var customerData in customerOrderCounts)
                {
                    // This is a placeholder - replace with your actual logic to fetch customer names
                    var customerName = await _userBusiness.GetEntity(customerData.CustomerId);

                    activeCustomers.Add(new ActiveCustomerDto
                    {
                        CustomerId = customerData.CustomerId,
                        OrderCount = customerData.OrderCount,
                        CustomerName = customerName.ApiReponse.Data.FullName
                    });
                }

                var report = new DashboardReportDto
                {
                    SalesSummary = salesSummary,
                    PendingOrdersCount = pendingOrdersCount,
                    MostActiveCustomers = activeCustomers
                };

                return new Response<DashboardReportDto>().Sucess(report, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Erro ao gerar o relatório do dashboard.");
                return new Response<DashboardReportDto>().Failure(default, message: "Erro ao gerar o relatório do dashboard.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<SalesSummaryDto>> GetSalesSummary()
        {
            try
            {
                var allOrdersResponse = await _orderBusiness.GetAllWithItemsAsync();
                if (!allOrdersResponse.ApiReponse.Success || allOrdersResponse.ApiReponse.Data == null)
                {
                    _logger.LogError("Erro ao obter todos os pedidos para o resumo de vendas.");
                    return new Response<SalesSummaryDto>().Failure(default, message: "Erro ao obter dados de pedidos.", statusCode: HttpStatusCode.InternalServerError);
                }
                var allOrders = allOrdersResponse.ApiReponse.Data;

                var salesSummary = new SalesSummaryDto
                {
                    TotalOrders = allOrders.Count(),
                    TotalRevenue = allOrders.Sum(o => o.TotalAmount),
                    TotalProductsSold = allOrders.Sum(o => o.OrderItems?.Sum(oi => oi.Quantity) ?? 0)
                };

                return new Response<SalesSummaryDto>().Sucess(salesSummary, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Erro ao gerar o resumo de vendas.");
                return new Response<SalesSummaryDto>().Failure(default, message: "Erro ao gerar o resumo de vendas.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<int>> GetPendingOrdersCount()
        {
            try
            {
                var allOrdersResponse = await _orderBusiness.GetAllWithItemsAsync();
                if (!allOrdersResponse.ApiReponse.Success || allOrdersResponse.ApiReponse.Data == null)
                {
                    _logger.LogError("Erro ao obter todos os pedidos para contar os pendentes.");
                    return new Response<int>().Failure(default, message: "Erro ao obter dados de pedidos.", statusCode: HttpStatusCode.InternalServerError);
                }
                var allOrders = allOrdersResponse.ApiReponse.Data;

                var pendingOrdersCount = allOrders.Count(o => o.Status == OrderStatus.Pending);

                return new Response<int>().Sucess(pendingOrdersCount, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Erro ao obter a contagem de pedidos pendentes.");
                return new Response<int>().Failure(default, message: "Erro ao obter a contagem de pedidos pendentes.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<List<ActiveCustomerDto>>> GetMostActiveCustomers()
        {
            try
            {
                var allOrdersResponse = await _orderBusiness.GetAllWithItemsAsync();
                if (!allOrdersResponse.ApiReponse.Success || allOrdersResponse.ApiReponse.Data == null)
                {
                    _logger.LogError("Erro ao obter todos os pedidos para os clientes mais ativos.");
                    return new Response<List<ActiveCustomerDto>>().Failure(default, message: "Erro ao obter dados de pedidos.", statusCode: HttpStatusCode.InternalServerError);
                }
                var allOrders = allOrdersResponse.ApiReponse.Data;

                var customerOrderCounts = allOrders
                    .GroupBy(o => o.CreateByUserUuid)
                    .Select(g => new { CustomerId = g.Key, OrderCount = g.Count() })
                    .OrderByDescending(c => c.OrderCount)
                    .Take(5);

                var activeCustomers = new List<ActiveCustomerDto>();
                foreach (var customerData in customerOrderCounts)
                {
                    var userResponse = await _userBusiness.GetEntity(customerData.CustomerId);
                    if (userResponse.ApiReponse.Success && userResponse.ApiReponse.Data != null && userResponse.ApiReponse.Data.UserRole == UserRole.Client)
                    {
                        activeCustomers.Add(new ActiveCustomerDto
                        {
                            CustomerId = customerData.CustomerId,
                            OrderCount = customerData.OrderCount,
                            CustomerName = userResponse.ApiReponse.Data.FullName
                        });
                    }
                }

                return new Response<List<ActiveCustomerDto>>().Sucess(activeCustomers, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Erro ao obter os clientes mais ativos.");
                return new Response<List<ActiveCustomerDto>>().Failure(default, message: "Erro ao obter os clientes mais ativos.", statusCode: HttpStatusCode.InternalServerError);
            }
        }
    }
}
using Microsoft.Extensions.Logging;
using SalesOrderManagement.Application.Dtos.Auth;
using SharedKernel.Utils.Crypto;
using SharedKernel.Utils;
using System.Net;
using SalesOrderManagement.Application.Authentication;
using SalesOrderManagement.Domain.Entities;
using SalesOrderManagement.Domain.Entities._bases;
using SalesOrderManagement.Application.Interfaces;
using SalesOrderManagement.Application.Interfaces.Business;
using SalesOrderManagement.Application.Interfaces.UseCases;
using SalesOrderManagement.Domain.Errors;

namespace SalesOrderManagement.Application.UseCases
{
    public class UserAuthentication(IUserBusiness userBusiness, ITokenService tokenService, ILogger<UserAuthentication> logger) : IUserAuthentication
    {
        private readonly IUserBusiness _userBusiness = userBusiness;
        private readonly ITokenService _tokenService = tokenService;
        private readonly ILogger<UserAuthentication> _logger = logger;

        public async Task<Response<AuthenticationResponse>> Login(string email, string password)
        {
            var response = new Response<AuthenticationResponse>
            {
                StatusCode = HttpStatusCode.Unauthorized,
                ApiReponse = new ApiResponse<AuthenticationResponse>
                {
                    Success = false,
                    Data = null,
                    ErrorCode = (int)HttpStatusCode.Unauthorized,
                    Message = Error.INVALID_EMAIL_OR_PASSWORD,
                }
            };

            try
            {
                var userResult = await _userBusiness.Get(email);
                if (userResult.ApiReponse.Data is null)
                {
                    return response;
                }

                if (!BCryptService.VerifyPassword(password, userResult.ApiReponse.Data.Password))
                {
                    return response;
                }

                var authenticationResult = await AuthenticateUser(userResult.ApiReponse.Data);
                if (!authenticationResult.Success || authenticationResult.Data is null)
                {
                    response.ApiReponse = authenticationResult;
                    return response;
                }

                response.StatusCode = HttpStatusCode.OK;
                response.ApiReponse.ErrorCode = null;

                response.ApiReponse = authenticationResult;

            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during login.");
                response.StatusCode = HttpStatusCode.InternalServerError;
                response.ApiReponse.Success = false;
                response.ApiReponse.ErrorCode = (int)HttpStatusCode.InternalServerError;
                response.ApiReponse.Message = Error.UNEXPECTED_ERROR + " during login.";
            }

            return response;

        }

        private async Task<ApiResponse<AuthenticationResponse>> AuthenticateUser(User user)
        {
            ApiResponse<AuthenticationResponse> response = new()
            {
                Success = true,
                Data = new AuthenticationResponse(),
                ErrorCode = 0,
                Message = Const.MESSAGE_LOGIN_SUCCESS,
            };

            var userToken = new UserAuthenticateJWT
            {
                UserUuid = user.UUID,
                UserEmail = user.Email,
                UserName = user.FullName,
                UserRole = user.UserRole.ToString(),
            };

            var accessTokenResult = await _tokenService.GenerateJwtToken(userToken);
            response.Data.AccessToken = accessTokenResult.AccessToken;
            response.Data.ExpiresIn = accessTokenResult.ExpiresIn;

            return response;
        }
    }
}

Business
using Mapster;
using Microsoft.Extensions.Logging;
using SalesOrderManagement.Application.Dtos.Entities.Order;
using SalesOrderManagement.Domain.Entities;
using SalesOrderManagement.Domain.Errors;
using SalesOrderManagement.Domain.Interfaces.Repositories;
using SharedKernel.Utils;
using System.Net;
using SalesOrderManagement.Domain.Entities._bases;
using SalesOrderManagement.Application.Interfaces.Business;

namespace SalesOrderManagement.Application.Business
{
    public class OrderBusiness(IOrderRepository orderRepository, ILogger<OrderBusiness> logger) : IOrderBusiness
    {
        private readonly IOrderRepository _orderRepository = orderRepository;
        private readonly ILogger<OrderBusiness> _logger = logger;

        public async Task<Response<Guid>> Add(CreateOrderDto createOrderDto)
        {
            try
            {
                var order = createOrderDto.Adapt<Order>();
                order.Validate();

                await _orderRepository.Add(order);
                _logger.LogInformation($"Pedido criado com UUID: {order.UUID} e número: {order.OrderNumber}");
                return new Response<Guid>().Sucess(order.UUID, message: Const.CREATE_SUCCESS, statusCode: HttpStatusCode.Created);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Erro ao adicionar novo pedido.");
                return new Response<Guid>().Failure(default, message: "Erro ao adicionar novo pedido.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<bool>> Delete(int id)
        {
            try
            {
                var deleted = await _orderRepository.Delete(id);
                if (deleted)
                {
                    _logger.LogInformation($"Pedido com ID: {id} deletado com sucesso.");
                    return new Response<bool>().Sucess(true, message: Const.DELETE_SUCCESS, statusCode: HttpStatusCode.OK);
                }
                else
                {
                    _logger.LogWarning($"Falha ao deletar pedido com ID: {id}.");
                    return new Response<bool>().Failure(false, message: "Falha ao deletar pedido.", statusCode: HttpStatusCode.InternalServerError);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar deletar pedido com ID: {id}.");
                return new Response<bool>().Failure(false, message: "Erro ao deletar pedido.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<bool>> Delete(Guid guid)
        {
            try
            {
                var orderToDelete = await _orderRepository.Get(guid);
                if (orderToDelete == null)
                {
                    return new Response<bool>().Failure(false, message: Error.ORDER_NOT_FOUND, statusCode: HttpStatusCode.NotFound);
                }

                var result = await _orderRepository.Delete(orderToDelete.UUID);
                if (result)
                {
                    _logger.LogInformation($"Pedido com UUID: {guid} deletado com sucesso.");
                    return new Response<bool>().Sucess(true, message: Const.DELETE_SUCCESS, statusCode: HttpStatusCode.OK);
                }
                else
                {
                    _logger.LogWarning($"Falha ao deletar pedido com UUID: {guid}.");
                    return new Response<bool>().Failure(false, message: "Falha ao deletar pedido.", statusCode: HttpStatusCode.InternalServerError);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar deletar pedido com UUID: {guid}.");
                return new Response<bool>().Failure(false, message: "Erro ao deletar pedido.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<OrderDto>> Get(int id)
        {
            try
            {
                var order = await _orderRepository.Get(id);
                if (order == null)
                {
                    return new Response<OrderDto>().Failure(default, message: Error.ORDER_NOT_FOUND, statusCode: HttpStatusCode.NotFound);
                }
                var orderDto = order.Adapt<OrderDto>();
                return new Response<OrderDto>().Sucess(orderDto, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar obter pedido com ID: {id}.");
                return new Response<OrderDto>().Failure(default, message: "Erro ao obter pedido.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<IEnumerable<OrderDto>>> GetAll()
        {
            try
            {
                var orders = await _orderRepository.GetAllWithItemsAsync();
                var orderDtos = orders.Adapt<IEnumerable<OrderDto>>();
                return new Response<IEnumerable<OrderDto>>().Sucess(orderDtos, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Erro ao obter todos os pedidos.");
                return new Response<IEnumerable<OrderDto>>().Failure(default, message: "Erro ao obter todos os pedidos.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<OrderDto>> GetDto(Guid guid)
        {
            try
            {
                var order = await _orderRepository.Get(guid);
                if (order == null)
                {
                    return new Response<OrderDto>().Failure(default, message: Error.ORDER_NOT_FOUND, statusCode: HttpStatusCode.NotFound);
                }
                var orderDto = order.Adapt<OrderDto>();
                return new Response<OrderDto>().Sucess(orderDto, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar obter pedido com UUID: {guid} como DTO.");
                return new Response<OrderDto>().Failure(default, message: "Erro ao obter pedido.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<Order>> GetEntity(Guid guid)
        {
            try
            {
                var order = await _orderRepository.Get(guid);
                if (order == null)
                {
                    return new Response<Order>().Failure(default, message: Error.ORDER_NOT_FOUND, statusCode: HttpStatusCode.NotFound);
                }
                return new Response<Order>().Sucess(order, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar obter pedido com UUID: {guid} como entidade.");
                return new Response<Order>().Failure(default, message: "Erro ao obter pedido.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<bool>> Update(UpdateOrderDto updateOrderDto)
        {
            try
            {
                var existingOrder = await _orderRepository.Get(updateOrderDto.UUID);
                if (existingOrder == null)
                {
                    return new Response<bool>().Failure(false, message: Error.ORDER_NOT_FOUND, statusCode: HttpStatusCode.NotFound);
                }

                updateOrderDto.Adapt(existingOrder);
                existingOrder.UpdateAt = DateTime.UtcNow;
                existingOrder.Validate();

                var result = await _orderRepository.Update(existingOrder);
                if (result)
                {
                    _logger.LogInformation($"Pedido com UUID: {updateOrderDto.UUID} atualizado com sucesso.");
                    return new Response<bool>().Sucess(true, message: Const.UPDATE_SUCCESS, statusCode: HttpStatusCode.OK);
                }
                else
                {
                    _logger.LogWarning($"Falha ao atualizar pedido com UUID: {updateOrderDto.UUID}.");
                    return new Response<bool>().Failure(false, message: "Falha ao atualizar pedido.", statusCode: HttpStatusCode.InternalServerError);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar atualizar pedido com UUID: {updateOrderDto.UUID}.");
                return new Response<bool>().Failure(false, message: "Erro ao atualizar pedido.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<IEnumerable<OrderDto>>> GetOrdersByUserId(Guid userId)
        {
            try
            {
                var orders = await _orderRepository.GetOrdersByUserId(userId);
                var orderDtos = orders.Adapt<IEnumerable<OrderDto>>();
                return new Response<IEnumerable<OrderDto>>().Sucess(orderDtos, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao obter pedidos do usuário com UUID: {userId}.");
                return new Response<IEnumerable<OrderDto>>().Failure(default, message: "Erro ao obter pedidos do usuário.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<IEnumerable<OrderDto>>> GetOrdersByStatus(string status)
        {
            try
            {
                if (!Enum.TryParse<Enums.OrderStatus>(status, true, out var orderStatus))
                {
                    return new Response<IEnumerable<OrderDto>>().Failure(default, message: "Status de pedido inválido.", statusCode: HttpStatusCode.BadRequest);
                }
                var orders = await _orderRepository.GetOrdersByStatus(orderStatus);
                var orderDtos = orders.Adapt<IEnumerable<OrderDto>>();
                return new Response<IEnumerable<OrderDto>>().Sucess(orderDtos, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao obter pedidos com status: {status}.");
                return new Response<IEnumerable<OrderDto>>().Failure(default, message: "Erro ao obter pedidos por status.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<IEnumerable<OrderDto>>> GetOrdersByDateRange(DateTime startDate, DateTime endDate)
        {
            try
            {
                var orders = await _orderRepository.GetOrdersByDateRange( startDate , endDate);
                var orderDtos = orders.Adapt<IEnumerable<OrderDto>>();
                return new Response<IEnumerable<OrderDto>>().Sucess(orderDtos, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao obter pedidos no período de {startDate} a {endDate}.");
                return new Response<IEnumerable<OrderDto>>().Failure(default, message: "Erro ao obter pedidos por período.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<OrderDto>> GetOrderWithOrdemItems(Guid uuid)
        {
            try
            {
                var order = await _orderRepository.GetOrderWithOrdemItems(uuid);
                if (order == null)
                {
                    return new Response<OrderDto>().Failure(default, message: Error.ORDER_NOT_FOUND, statusCode: HttpStatusCode.NotFound);
                }
                var orderDto = order.Adapt<OrderDto>();
                return new Response<OrderDto>().Sucess(orderDto, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao obter pedido com UUID: {uuid} e seus itens.");
                return new Response<OrderDto>().Failure(default, message: "Erro ao obter pedido com itens.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<IEnumerable<OrderDto>>> GetAllWithItemsAsync()
        {
            try
            {
                var orders = await _orderRepository.GetAllWithItemsAsync();
                var orderDtos = orders.Adapt<IEnumerable<OrderDto>>();
                return new Response<IEnumerable<OrderDto>>().Sucess(orderDtos, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Erro ao obter todos os pedidos com seus itens.");
                return new Response<IEnumerable<OrderDto>>().Failure(default, message: "Erro ao obter todos os pedidos com itens.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

    }
}
using Microsoft.Extensions.Logging;
using SalesOrderManagement.Application.Dtos.Entities.OrderItem;
using SalesOrderManagement.Application.Interfaces.Business;
using SalesOrderManagement.Domain.Entities._bases;
using SalesOrderManagement.Domain.Entities;
using SalesOrderManagement.Domain.Interfaces.Repositories;
using SharedKernel.Utils;
using System.Net;
using Mapster;
using SalesOrderManagement.Domain.Errors;

namespace SalesOrderManagement.Application.Business
{
    public class OrderItemBusiness(IOrderItemRepository orderItemRepository, IProductRepository productRepository, ILogger<OrderItemBusiness> logger) : IOrderItemBusiness
    {
        private readonly IOrderItemRepository _orderItemRepository = orderItemRepository;
        private readonly IProductRepository _productRepository = productRepository; 
        private readonly ILogger<OrderItemBusiness> _logger = logger;

        public async Task<Response<Guid>> Add(CreateOrderItemDto createOrderItemDto)
        {
            try
            {
                var product = await _productRepository.Get(createOrderItemDto.ProductId);
                if (product == null)
                {
                    return new Response<Guid>().Failure(default, message: Error.PRODUCT_NOT_FOUND, statusCode: HttpStatusCode.NotFound);
                }

                var orderItem = createOrderItemDto.Adapt<OrderItem>();
                orderItem.UnitPrice = product.Price; 
                orderItem.CalculateTotalPrice();
                orderItem.Validate();

                await _orderItemRepository.Add(orderItem);
                _logger.LogInformation($"Item de pedido criado com UUID: {orderItem.UUID} para o produto: {product.Name}");
                return new Response<Guid>().Sucess(orderItem.UUID, message: Const.CREATE_SUCCESS, statusCode: HttpStatusCode.Created);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Erro ao adicionar novo item de pedido.");
                return new Response<Guid>().Failure(default, message: "Erro ao adicionar novo item de pedido.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<bool>> Delete(int id)
        {
            try
            {
                var deleted = await _orderItemRepository.Delete(id);
                if (deleted)
                {
                    _logger.LogInformation($"Item de pedido com ID: {id} deletado com sucesso.");
                    return new Response<bool>().Sucess(true, message: Const.DELETE_SUCCESS, statusCode: HttpStatusCode.OK);
                }
                else
                {
                    _logger.LogWarning($"Falha ao deletar item de pedido com ID: {id}.");
                    return new Response<bool>().Failure(false, message: "Falha ao deletar item de pedido.", statusCode: HttpStatusCode.InternalServerError);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar deletar item de pedido com ID: {id}.");
                return new Response<bool>().Failure(false, message: "Erro ao deletar item de pedido.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<bool>> Delete(Guid guid)
        {
            try
            {
                var orderItemToDelete = await _orderItemRepository.Get(guid);
                if (orderItemToDelete == null)
                {
                    return new Response<bool>().Failure(false, message: Error.ORDER_ITEM_NOT_FOUND, statusCode: HttpStatusCode.NotFound);
                }

                var result = await _orderItemRepository.Delete(orderItemToDelete.UUID);
                if (result)
                {
                    _logger.LogInformation($"Item de pedido com UUID: {guid} deletado com sucesso.");
                    return new Response<bool>().Sucess(true, message: Const.DELETE_SUCCESS, statusCode: HttpStatusCode.OK);
                }
                else
                {
                    _logger.LogWarning($"Falha ao deletar item de pedido com UUID: {guid}.");
                    return new Response<bool>().Failure(false, message: "Falha ao deletar item de pedido.", statusCode: HttpStatusCode.InternalServerError);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar deletar item de pedido com UUID: {guid}.");
                return new Response<bool>().Failure(false, message: "Erro ao deletar item de pedido.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<OrderItemDto>> Get(int id)
        {
            try
            {
                var orderItem = await _orderItemRepository.Get(id);
                if (orderItem == null)
                {
                    return new Response<OrderItemDto>().Failure(default, message: Error.ORDER_ITEM_NOT_FOUND, statusCode: HttpStatusCode.NotFound);
                }
                var orderItemDto = orderItem.Adapt<OrderItemDto>();
                return new Response<OrderItemDto>().Sucess(orderItemDto, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar obter item de pedido com ID: {id}.");
                return new Response<OrderItemDto>().Failure(default, message: "Erro ao obter item de pedido.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<IEnumerable<OrderItemDto>>> GetAll()
        {
            try
            {
                var orderItems = await _orderItemRepository.GetAllWithProductAsync();
                var orderItemDtos = orderItems.Adapt<IEnumerable<OrderItemDto>>();
                return new Response<IEnumerable<OrderItemDto>>().Sucess(orderItemDtos, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Erro ao obter todos os itens de pedido.");
                return new Response<IEnumerable<OrderItemDto>>().Failure(default, message: "Erro ao obter todos os itens de pedido.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<OrderItemDto>> GetDto(Guid guid)
        {
            try
            {
                var orderItem = await _orderItemRepository.Get(guid);
                if (orderItem == null)
                {
                    return new Response<OrderItemDto>().Failure(default, message: Error.ORDER_ITEM_NOT_FOUND, statusCode: HttpStatusCode.NotFound);
                }
                var orderItemDto = orderItem.Adapt<OrderItemDto>();
                return new Response<OrderItemDto>().Sucess(orderItemDto, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar obter item de pedido com UUID: {guid} como DTO.");
                return new Response<OrderItemDto>().Failure(default, message: "Erro ao obter item de pedido.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<OrderItem>> GetEntity(Guid guid)
        {
            try
            {
                var orderItem = await _orderItemRepository.GetOrderItemWithProduct(guid);
                if (orderItem == null)
                {
                    return new Response<OrderItem>().Failure(default, message: Error.ORDER_ITEM_NOT_FOUND, statusCode: HttpStatusCode.NotFound);
                }
                return new Response<OrderItem>().Sucess(orderItem, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar obter item de pedido com UUID: {guid} como entidade.");
                return new Response<OrderItem>().Failure(default, message: "Erro ao obter item de pedido.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<bool>> Update(UpdateOrderItemDto updateOrderItemDto)
        {
            try
            {
                var existingOrderItem = await _orderItemRepository.GetOrderItemWithProduct(updateOrderItemDto.UUID);
                if (existingOrderItem == null)
                {
                    return new Response<bool>().Failure(false, message: Error.ORDER_ITEM_NOT_FOUND, statusCode: HttpStatusCode.NotFound);
                }

                if (existingOrderItem.Product == null)
                {
                    return new Response<bool>().Failure(false, message: Error.PRODUCT_NOT_FOUND, statusCode: HttpStatusCode.NotFound);
                }

                updateOrderItemDto.Adapt(existingOrderItem);
                existingOrderItem.UnitPrice = existingOrderItem.Product.Price; // Atualizar o preço se o produto mudar? Considere a lógica de precificação.
                existingOrderItem.TotalPrice = existingOrderItem.UnitPrice * existingOrderItem.Quantity;
                existingOrderItem.UpdateAt = DateTime.UtcNow;

                var result = await _orderItemRepository.Update(existingOrderItem);
                if (result)
                {
                    _logger.LogInformation($"Item de pedido com UUID: {updateOrderItemDto.UUID} atualizado com sucesso.");
                    return new Response<bool>().Sucess(true, message: Const.UPDATE_SUCCESS, statusCode: HttpStatusCode.OK);
                }
                else
                {
                    _logger.LogWarning($"Falha ao atualizar item de pedido com UUID: {updateOrderItemDto.UUID}.");
                    return new Response<bool>().Failure(false, message: "Falha ao atualizar item de pedido.", statusCode: HttpStatusCode.InternalServerError);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar atualizar item de pedido com UUID: {updateOrderItemDto.UUID}.");
                return new Response<bool>().Failure(false, message: "Erro ao atualizar item de pedido.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<IEnumerable<OrderItemDto>>> GetOrderItemsByOrderId(Guid orderId)
        {
            try
            {
                var orderItems = await _orderItemRepository.GetOrderItemsByOrderId(orderId);
                var orderItemDtos = orderItems.Adapt<IEnumerable<OrderItemDto>>();
                return new Response<IEnumerable<OrderItemDto>>().Sucess(orderItemDtos, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao obter itens de pedido para o pedido com UUID: {orderId}.");
                return new Response<IEnumerable<OrderItemDto>>().Failure(default, message: "Erro ao obter itens de pedido por OrderId.", statusCode: HttpStatusCode.InternalServerError);
            }
        }
    }
}
using Mapster;
using Microsoft.Extensions.Logging;
using SalesOrderManagement.Application.Dtos.Entities.Product;
using SalesOrderManagement.Application.Interfaces.Business;
using SalesOrderManagement.Domain.Entities;
using SalesOrderManagement.Domain.Entities._bases;
using SalesOrderManagement.Domain.Errors;
using SalesOrderManagement.Domain.Interfaces.Repositories;
using SharedKernel.Utils;
using System.Net;

namespace SalesOrderManagement.Application.Business
{
    public class ProductBusiness : IProductBusiness
    {
        private readonly IProductRepository _productRepository;
        private readonly ILogger<ProductBusiness> _logger;

        public ProductBusiness(IProductRepository productRepository, ILogger<ProductBusiness> logger)
        {
            _productRepository = productRepository;
            _logger = logger;
        }

        public async Task<Response<Guid>> Add(CreateProductDto createProductDto)
        {
            try
            {
                var product = createProductDto.Adapt<Product>();
                await _productRepository.Add(product);
                _logger.LogInformation($"Produto criado com UUID: {product.UUID}");
                return new Response<Guid>().Sucess(product.UUID, message: Const.CREATE_SUCCESS, statusCode: HttpStatusCode.Created);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Erro ao adicionar novo produto.");
                return new Response<Guid>().Failure(default, message: "Erro ao adicionar novo produto.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<bool>> Delete(int id)
        {
            try
            {
                var deleted = await _productRepository.Delete(id);
                if (deleted)
                {
                    _logger.LogInformation($"Produto com ID: {id} deletado com sucesso.");
                    return new Response<bool>().Sucess(true, message: Const.DELETE_SUCCESS, statusCode: HttpStatusCode.OK);
                }
                else
                {
                    _logger.LogWarning($"Falha ao deletar produto com ID: {id}.");
                    return new Response<bool>().Failure(false, message: "Falha ao deletar produto.", statusCode: HttpStatusCode.InternalServerError);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar deletar produto com ID: {id}.");
                return new Response<bool>().Failure(false, message: "Erro ao deletar produto.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<bool>> Delete(Guid guid)
        {
            try
            {
                var productToDelete = await _productRepository.Get(guid);
                if (productToDelete == null)
                {
                    return new Response<bool>().Failure(false, message: Error.PRODUCT_NOT_FOUND, statusCode: HttpStatusCode.NotFound);
                }

                var result = await _productRepository.Delete(productToDelete.UUID);
                if (result)
                {
                    _logger.LogInformation($"Produto com UUID: {guid} deletado com sucesso.");
                    return new Response<bool>().Sucess(true, message: Const.DELETE_SUCCESS, statusCode: HttpStatusCode.OK);
                }
                else
                {
                    _logger.LogWarning($"Falha ao deletar produto com UUID: {guid}.");
                    return new Response<bool>().Failure(false, message: "Falha ao deletar produto.", statusCode: HttpStatusCode.InternalServerError);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar deletar produto com UUID: {guid}.");
                return new Response<bool>().Failure(false, message: "Erro ao deletar produto.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<ProductDto>> Get(int id)
        {
            try
            {
                var product = await _productRepository.Get(id);
                if (product == null)
                {
                    return new Response<ProductDto>().Failure(default, message: Error.PRODUCT_NOT_FOUND, statusCode: HttpStatusCode.NotFound);
                }
                var productDto = product.Adapt<ProductDto>();
                return new Response<ProductDto>().Sucess(productDto, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar obter produto com ID: {id}.");
                return new Response<ProductDto>().Failure(default, message: "Erro ao obter produto.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public Task<Response<IEnumerable<ProductDto>>> GetAll()
        {
            var products = _productRepository.GetAll();
            var productDtos = products.Adapt<IEnumerable<ProductDto>>();
            return Task.FromResult(new Response<IEnumerable<ProductDto>>().Sucess(productDtos, statusCode: HttpStatusCode.OK));

        }

        public Task<Response<IEnumerable<ProductDto>>> GetAllByCategory(string category)
        {
            var products = _productRepository.GetAllByCategory(category);
            var productDtos = products.Adapt<IEnumerable<ProductDto>>();
            return Task.FromResult(new Response<IEnumerable<ProductDto>>().Sucess(productDtos, statusCode: HttpStatusCode.OK));
        }

        public async Task<Response<ProductDto>> GetDto(Guid guid)
        {
            try
            {
                var product = await _productRepository.Get(guid);
                if (product == null)
                {
                    return new Response<ProductDto>().Failure(default, message: "Produto não encontrado.", statusCode: HttpStatusCode.NotFound);
                }
                var productDto = product.Adapt<ProductDto>();
                return new Response<ProductDto>().Sucess(productDto, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar obter produto com UUID: {guid} como DTO.");
                return new Response<ProductDto>().Failure(default, message: "Erro ao obter produto.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<Product>> GetEntity(Guid guid)
        {
            try
            {
                var product = await _productRepository.Get(guid);
                if (product == null)
                {
                    return new Response<Product>().Failure(default, message: Error.PRODUCT_NOT_FOUND, statusCode: HttpStatusCode.NotFound);
                }
                return new Response<Product>().Sucess(product, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar obter produto com UUID: {guid} como entidade.");
                return new Response<Product>().Failure(default, message: "Erro ao obter produto.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<bool>> Update(UpdateProductDto updateProductDto)
        {
            try
            {
                var existingProduct = await _productRepository.Get(updateProductDto.UUID);
                if (existingProduct == null)
                {
                    return new Response<bool>().Failure(false, message: Error.PRODUCT_NOT_FOUND, statusCode: HttpStatusCode.NotFound);
                }

                updateProductDto.Adapt(existingProduct);
                existingProduct.UpdateAt = DateTime.UtcNow;
                var result = await _productRepository.Update(existingProduct);
                if (result)
                {
                    _logger.LogInformation($"Produto com UUID: {updateProductDto.UUID} atualizado com sucesso.");
                    return new Response<bool>().Sucess(true, message: Const.UPDATE_SUCCESS, statusCode: HttpStatusCode.OK);
                }
                else
                {
                    _logger.LogWarning($"Falha ao atualizar produto com UUID: {updateProductDto.UUID}.");
                    return new Response<bool>().Failure(false, message: "Falha ao atualizar produto.", statusCode: HttpStatusCode.InternalServerError);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar atualizar produto com UUID: {updateProductDto.UUID}.");
                return new Response<bool>().Failure(false, message: "Erro ao atualizar produto.", statusCode: HttpStatusCode.InternalServerError);
            }
        }
    }
}
using Mapster;
using Microsoft.Extensions.Logging;
using SalesOrderManagement.Application.Dtos.Entities.User;
using SalesOrderManagement.Application.Interfaces.Business;
using SalesOrderManagement.Domain.Entities;
using SalesOrderManagement.Domain.Entities._bases;
using SalesOrderManagement.Domain.Interfaces.Repositories;
using SharedKernel.Utils;
using System.Net;
using static SalesOrderManagement.Domain.Entities._bases.Enums;

namespace SalesOrderManagement.Application.Business
{
    public class UserBusiness(IUserRepository userRepository, ILogger<UserBusiness> logger) : IUserBusiness
    {
        private readonly IUserRepository _userRepository = userRepository;
        private readonly ILogger<UserBusiness> _logger = logger;

        public async Task<Response<Guid>> Add(CreateUserDto createUserDto)
        {
            try
            {
                var existingUserByEmail = await _userRepository.GetByEmail(createUserDto.Email);
                if (existingUserByEmail != null)
                {
                    return new Response<Guid>().Failure(default, message: Const.CREATE_SUCCESS, statusCode: HttpStatusCode.Conflict);
                }

                var existingUserByDocument = await _userRepository.GetByDocument(createUserDto.Document);
                if (existingUserByDocument != null)
                {
                    return new Response<Guid>().Failure(default, message: "Já existe um usuário cadastrado com este documento.", statusCode: HttpStatusCode.Conflict);
                }

                var existingUserByPhone = await _userRepository.GetByPhone(createUserDto.Phone);
                if (existingUserByPhone != null)
                {
                    return new Response<Guid>().Failure(default, message: "Já existe um usuário cadastrado com este telefone.", statusCode: HttpStatusCode.Conflict);
                }

                var user = createUserDto.Adapt<User>();
                user.Password = BCrypt.Net.BCrypt.HashPassword(user.Password); // Hash da senha antes de salvar
                user.Validate();
                await _userRepository.Add(user);
                _logger.LogInformation($"Usuário criado com UUID: {user.UUID}");
                return new Response<Guid>().Sucess(user.UUID, statusCode: HttpStatusCode.Created);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Erro ao adicionar novo usuário.");
                return new Response<Guid>().Failure(default, message: "Erro ao adicionar novo usuário.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<bool>> Delete(int id)
        {
            try
            {
                // Implementar lógica de exclusão por ID (se necessário)
                throw new NotImplementedException();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar deletar usuário com ID: {id}.");
                return new Response<bool>().Failure(false, message: "Erro ao deletar usuário.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<bool>> Delete(Guid guid)
        {
            try
            {
                var userToDelete = await _userRepository.Get(guid);
                if (userToDelete == null)
                {
                    return new Response<bool>().Failure(false, message: "Usuário não encontrado.", statusCode: HttpStatusCode.NotFound);
                }

                var result = await _userRepository.Delete(userToDelete.UUID);
                if (result)
                {
                    _logger.LogInformation($"Usuário com UUID: {guid} deletado com sucesso.");
                    return new Response<bool>().Sucess(result, statusCode: HttpStatusCode.OK);
                }
                else
                {
                    _logger.LogWarning($"Falha ao deletar usuário com UUID: {guid}.");
                    return new Response<bool>().Failure(false, message: "Falha ao deletar usuário.", statusCode: HttpStatusCode.InternalServerError);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar deletar usuário com UUID: {guid}.");
                return new Response<bool>().Failure(false, message: "Erro ao deletar usuário.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<UserDto>> Get(int id)
        {
            try
            {
                // Implementar lógica para obter DTO por ID (se necessário)
                throw new NotImplementedException();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar obter usuário com ID: {id}.");
                return new Response<UserDto>().Failure(default, message: "Erro ao obter usuário.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<UserDto>> GetDto(Guid guid)
        {
            try
            {
                var user = await _userRepository.Get(guid);
                if (user == null)
                {
                    return new Response<UserDto>().Failure(default, message: "Usuário não encontrado.", statusCode: HttpStatusCode.NotFound);
                }
                var userDto = user.Adapt<UserDto>();
                return new Response<UserDto>().Sucess(userDto, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar obter usuário com UUID: {guid} como DTO.");
                return new Response<UserDto>().Failure(default, message: "Erro ao obter usuário.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<User>> GetEntity(Guid guid)
        {
            try
            {
                var user = await _userRepository.Get(guid);
                if (user == null)
                {
                    return new Response<User>().Failure(default, message: "Usuário não encontrado.", statusCode: HttpStatusCode.NotFound);
                }
                return new Response<User>().Sucess(user, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar obter usuário com UUID: {guid} como entidade.");
                return new Response<User>().Failure(default, message: "Erro ao obter usuário.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<bool>> Update(UpdateUserDto updateUserDto)
        {
            try
            {
                var existingUser = await _userRepository.Get(updateUserDto.UUID);
                if (existingUser == null)
                {
                    return new Response<bool>().Failure(false, message: "Usuário não encontrado.", statusCode: HttpStatusCode.NotFound);
                }

                updateUserDto.Adapt(existingUser);
                // Adicionar lógica para não permitir atualização de senha aqui, criar método específico se necessário

                var result = await _userRepository.Update(existingUser);
                if (result)
                {
                    _logger.LogInformation($"Usuário com UUID: {updateUserDto.UUID} atualizado com sucesso.");
                    return new Response<bool>().Sucess(result, statusCode: HttpStatusCode.OK);
                }
                else
                {
                    _logger.LogWarning($"Falha ao atualizar usuário com UUID: {updateUserDto.UUID}.");
                    return new Response<bool>().Failure(false, message: "Falha ao atualizar usuário.", statusCode: HttpStatusCode.InternalServerError);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar atualizar usuário com UUID: {updateUserDto.UUID}.");
                return new Response<bool>().Failure(false, message: "Erro ao atualizar usuário.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<User>> Get(string email)
        {
            try
            {
                var user = await _userRepository.GetByEmail(email);
                if (user == null)
                {
                    return new Response<User>().Failure(default, message: "Usuário não encontrado com este e-mail.", statusCode: HttpStatusCode.NotFound);
                }
                return new Response<User>().Sucess(user, message: Const.MESSAGE_USER_FOUND, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar obter usuário com e-mail: {email}.");
                return new Response<User>().Failure(default, message: "Erro ao obter usuário.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<bool>> ChangePasswordAsync(ChangePasswordDto changePasswordDto)
        {
            try
            {
                var existingUser = await _userRepository.Get(changePasswordDto.UUID);
                if (existingUser == null)
                {
                    return new Response<bool>().Failure(false, message: "Usuário não encontrado.", statusCode: HttpStatusCode.NotFound);
                }

                if (!BCrypt.Net.BCrypt.Verify(changePasswordDto.OldPassword, existingUser.Password))
                {
                    return new Response<bool>().Failure(false, message: "A senha antiga está incorreta.", statusCode: HttpStatusCode.Unauthorized);
                }

                string newHashedPassword = BCrypt.Net.BCrypt.HashPassword(changePasswordDto.NewPassword);

                existingUser.Password = newHashedPassword;
                var updateResult = await _userRepository.Update(existingUser);

                if (updateResult)
                {
                    _logger.LogInformation($"Senha do usuário com UUID: {changePasswordDto.UUID} alterada com sucesso.");
                    return new Response<bool>().Sucess(true, message: "Senha alterada com sucesso.", statusCode: HttpStatusCode.OK);
                }
                else
                {
                    _logger.LogWarning($"Falha ao alterar a senha do usuário com UUID: {changePasswordDto.UUID}.");
                    return new Response<bool>().Failure(false, message: "Falha ao alterar a senha.", statusCode: HttpStatusCode.InternalServerError);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Erro ao tentar alterar a senha do usuário com UUID: {changePasswordDto.UUID}.");
                return new Response<bool>().Failure(false, message: "Erro ao alterar a senha.", statusCode: HttpStatusCode.InternalServerError);
            }
        }
        public async Task<Response<IEnumerable<UserDto>>> GetAll()
        {
            try
            {
                var users = await _userRepository.GetAll();
                var userDtos = users.Adapt<IEnumerable<UserDto>>();
                return new Response<IEnumerable<UserDto>>().Sucess(userDtos, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Erro ao tentar obter todos os usuários.");
                return new Response<IEnumerable<UserDto>>().Failure(default, message: "Erro ao obter todos os usuários.", statusCode: HttpStatusCode.InternalServerError);
            }
        }

        public async Task<Response<IEnumerable<UserDto>>> GetAllByRole(string role)
        {
            try
            {
                var roleEnum = Enum.Parse<UserRole>(role, true);
                var users = await _userRepository.GetAllByRole(roleEnum);


                var userDtos = users.Adapt<IEnumerable<UserDto>>();
                return new Response<IEnumerable<UserDto>>().Sucess(userDtos, statusCode: HttpStatusCode.OK);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Erro ao tentar obter todos os usuários.");
                return new Response<IEnumerable<UserDto>>().Failure(default, message: "Erro ao obter todos os usuários.", statusCode: HttpStatusCode.InternalServerError);
            }
        }
    }
}
fim da camada de serviço Segue Infra
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Microsoft.EntityFrameworkCore;
using SalesOrderManagement.Domain.Entities._bases;


namespace SalesOrderManagement.API.Infra.Configurations._bases
{
    public abstract class BaseEntityConfiguration<T> : IEntityTypeConfiguration<T> where T : EntityBase
    {
        protected string TableName { get; set; } = string.Empty;
        public virtual void Configure(EntityTypeBuilder<T> builder)
        {
            builder.ToTable(TableName);

            builder.HasKey(e => e.UUID);

            builder.Property(e => e.UUID)
                .IsRequired()
                .HasDefaultValueSql("gen_random_uuid()");
            builder.Property(e => e.Id)
                 .ValueGeneratedOnAdd();
            builder.HasIndex(e => e.Id)
                 .IsUnique();
            builder.Property(e => e.CreateAt)
                .IsRequired()
                .HasDefaultValueSql("CURRENT_TIMESTAMP");

            builder.Property(e => e.UpdateAt)
                .IsRequired(false);

        }

    }
}

using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Microsoft.EntityFrameworkCore;
using SalesOrderManagement.API.Infra.Configurations._bases;
using SalesOrderManagement.Domain.Entities;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using SalesOrderManagement.Domain.Entities._bases;

namespace SalesOrderManagement.API.Infra.Configurations
{
    public class OrderConfiguration : BaseEntityConfiguration<Order>
    {
        public override void Configure(EntityTypeBuilder<Order> builder)
        {
            TableName = "Orders"; 
            base.Configure(builder);


            builder.Property(o => o.OrderNumber)
                .IsRequired()
                .HasMaxLength(50);

            builder.Property(o => o.OrderDate)
                .IsRequired()
                .HasDefaultValueSql("CURRENT_TIMESTAMP");

            builder.Property(o => o.TotalAmount)
                .IsRequired()
                .HasPrecision(18, 2);

            builder.Property(o => o.ShippingAddress)
                .HasMaxLength(Const.ADDRESS_MAX_LENGTH);

            builder.Property(o => o.BillingAddress)
                .HasMaxLength(Const.ADDRESS_MAX_LENGTH);

            builder.Property(o => o.PaymentMethod)
                .IsRequired();

            builder.Property(o => o.Status)
                .IsRequired()
                .HasConversion<string>(); 

            builder.HasOne(o => o.CreateByUser)
                .WithMany(u => u.CreateByUser)
                .HasForeignKey(o => o.CreateByUserUuid)
                .OnDelete(DeleteBehavior.Restrict);

            builder.HasOne(o => o.ActionedByUser)
                .WithMany(u => u.ActionedOrders) 
                .HasForeignKey(o => o.ActionedByUserUuid)
                .OnDelete(DeleteBehavior.Restrict)
                .IsRequired(false);

            builder.Property(o => o.ActionedAt)
                .IsRequired(false);

            builder.HasMany(o => o.OrderItems)
                .WithOne(oi => oi.Order)
                .HasForeignKey(oi => oi.OrderId)
                .OnDelete(DeleteBehavior.Cascade);
        }
    }
}
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Microsoft.EntityFrameworkCore;
using SalesOrderManagement.API.Infra.Configurations._bases;
using SalesOrderManagement.Domain.Entities;

namespace SalesOrderManagement.API.Infra.Configurations
{
    public class OrderItemConfiguration : BaseEntityConfiguration<OrderItem>
    {
        public override void Configure(EntityTypeBuilder<OrderItem> builder)
        {
            TableName = "OrderItems"; 
            base.Configure(builder);

            builder.HasIndex(oi => new { oi.OrderId, oi.ProductId })
                .IsUnique();

            builder.HasOne(oi => oi.Order)
                .WithMany(o => o.OrderItems)
                .HasForeignKey(oi => oi.OrderId)
                .OnDelete(DeleteBehavior.Cascade);

            builder.HasOne(oi => oi.Product)
                .WithMany(p => p.OrderItems)
                .HasForeignKey(oi => oi.ProductId)
                .OnDelete(DeleteBehavior.Cascade);

            builder.Property(oi => oi.Quantity)
                .IsRequired();

            builder.Property(oi => oi.TotalPrice)
                .IsRequired()
                .HasPrecision(18, 2);

            builder.Property(oi => oi.UnitPrice)
                .IsRequired()
                .HasPrecision(18, 2);
        }
    }
}
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Microsoft.EntityFrameworkCore;
using SalesOrderManagement.API.Infra.Configurations._bases;
using SalesOrderManagement.Domain.Entities;
using SalesOrderManagement.Domain.Entities._bases;

namespace SalesOrderManagement.API.Infra.Configurations
{
    public class UserConfiguration : BaseEntityConfiguration<User>
    {
        public override void Configure(EntityTypeBuilder<User> builder)
        {
            TableName = "Users";

            base.Configure(builder);


            builder.Property(u => u.FullName)
                .IsRequired()
                .HasMaxLength(Const.NAME_MAX_LENGTH);

            builder.Property(u => u.Email)
                .IsRequired()
                .HasMaxLength(Const.EMAIL_MAX_LENGTH);

            builder.HasIndex(u => u.Email)
                .IsUnique();

            builder.Property(u => u.Phone)
                .HasMaxLength(Const.PHONE_MAX_LENGTH);

            builder.HasIndex(u => u.Phone)
                .IsUnique();

            builder.Property(u => u.Password)
                .IsRequired();

            builder.Property(u => u.Document)
                .HasMaxLength(Const.DOCUMENT_MAX_LENGTH);

            builder.HasIndex(u => u.Document)
                .IsUnique();

            builder.Property(u => u.UserRole)
                .IsRequired()
                .HasConversion<string>(); 

            builder.Property(u => u.IsActive)
                .IsRequired()
                .HasDefaultValue(true);

            builder.HasMany(u => u.CreateByUser)
                .WithOne(o => o.CreateByUser)
                .HasForeignKey(o => o.CreateByUserUuid)
                .OnDelete(DeleteBehavior.Restrict);

            builder.HasMany(u => u.ActionedOrders)
                .WithOne(o => o.ActionedByUser)
                .HasForeignKey(o => o.ActionedByUserUuid)
                .OnDelete(DeleteBehavior.Restrict)
                .IsRequired(false);
        }
    }
}
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using Microsoft.EntityFrameworkCore;
using SalesOrderManagement.API.Infra.Configurations._bases;
using SalesOrderManagement.Domain.Entities;
using SalesOrderManagement.Domain.Entities._bases;

namespace SalesOrderManagement.API.Infra.Configurations
{
    public class ProductConfiguration : BaseEntityConfiguration<Product>
    {
        public override void Configure(EntityTypeBuilder<Product> builder)
        {
            TableName = "Products";
            base.Configure(builder);

            builder.Property(p => p.Name)
                .IsRequired()
                .HasMaxLength(Const.NAME_MAX_LENGTH);

            builder.Property(p => p.Description)
                .HasMaxLength(Const.DESCRIPTION_MAX_LENGTH);

            builder.Property(p => p.Price)
                .IsRequired()
                .HasPrecision(18, 2);

            builder.Property(p => p.Quantity)
                .IsRequired();

            builder.Property(p => p.Category)
                .HasMaxLength(Const.CATEGORY_MAX_LENGTH);

            builder.Property(p => p.IsActive)
                .IsRequired()
                .HasDefaultValue(true);

            builder.HasMany(p => p.OrderItems)
                .WithOne(oi => oi.Product)
                .HasForeignKey(oi => oi.ProductId)
                .OnDelete(DeleteBehavior.Cascade);
        }
    }
}
using DotNetEnv;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using SalesOrderManagement.API.Infra.Configurations;
using SalesOrderManagement.Domain.Entities;

namespace SalesOrderManagement.API.Infra.Context
{
    public class AppDbContext : DbContext
    {
        public DbSet<User> Users { get; set; }
        public DbSet<Product> Products { get; set; }
        public DbSet<Order> Orders { get; set; }
        public DbSet<OrderItem> OrderItems { get; set; }

        public AppDbContext(DbContextOptions<AppDbContext> options) : base(options)
        {

        }

        public AppDbContext()
        {

        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.ApplyConfigurationsFromAssembly(typeof(UserConfiguration).Assembly);

        }
        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            if (!optionsBuilder.IsConfigured)
            {
                base.OnConfiguring(optionsBuilder);

                // Usado dessa maneira somente para usar os migrations.
                Env.TraversePath().Load();
                
                string connectString = Environment.GetEnvironmentVariable("DATABASE_URL");
                optionsBuilder.UseNpgsql(connectString,
                    npgsqlOptionsAction: sqlOptions =>
                    {
                        sqlOptions.MigrationsAssembly(typeof(AppDbContext).Assembly.GetName().Name);
                    });
            }
        }
    }
}
using Microsoft.EntityFrameworkCore;
using SalesOrderManagement.API.Infra.Context;
using SalesOrderManagement.Domain.Entities._bases;
using SalesOrderManagement.Domain.Interfaces._bases;

namespace SalesOrderManagement.API.Infra.Repositories._bases
{
    public abstract class RepositoryBase<T> : IRepositoryBase<T> where T : EntityBase
    {
        private readonly AppDbContext _context;
        protected readonly DbSet<T> _dbSet;

        protected RepositoryBase(AppDbContext context)
        {
            _context = context;
            _dbSet = _context.Set<T>();
        }

        public async Task<Guid> Add(T entity)
        {
            await _dbSet.AddAsync(entity);
            await _context.SaveChangesAsync();
            return entity.UUID;
        }

        public async Task<bool> Delete(int id)
        {
            var entity = await _dbSet.FindAsync(id);
            if (entity == null)
                return false;

            _dbSet.Remove(entity);
            await _context.SaveChangesAsync();
            return true;
        }

        public async Task<bool> Delete(Guid guid)
        {
            var entity = await _dbSet.FirstOrDefaultAsync(e => e.UUID == guid);
            if (entity == null)
                return false;

            _dbSet.Remove(entity);
            await _context.SaveChangesAsync();
            return true;
        }

        public async Task<T> Get(int id) => await _dbSet.FindAsync(id);

        public async Task<T> Get(Guid uuid) => await _dbSet.FirstOrDefaultAsync(e => e.UUID == uuid);

        public async Task<bool> Update(T entity)
        {
            var existingEntity = await _dbSet.FirstOrDefaultAsync(e => e.UUID == entity.UUID);
            if (existingEntity == null)
                return false;

            _context.Entry(existingEntity).CurrentValues.SetValues(entity);
            await _context.SaveChangesAsync();
            return true;
        }
        public async Task<List<Guid>> AddRangeOfEntitiesAsync(List<T> entityList)
        {
            if (entityList != null && entityList.Count != 0)
            {
                await _context.Set<T>().AddRangeAsync(entityList);
                await _context.SaveChangesAsync();
                return [.. entityList.Select(b => b.UUID)];

            }
            return [];
        }
    }
}
using Microsoft.EntityFrameworkCore;
using SalesOrderManagement.API.Infra.Context;
using SalesOrderManagement.API.Infra.Repositories._bases;
using SalesOrderManagement.Domain.Entities;
using SalesOrderManagement.Domain.Interfaces.Repositories;

namespace SalesOrderManagement.API.Infra.Repositories
{
    public class OrderItemRepository(AppDbContext context) : RepositoryBase<OrderItem>(context), IOrderItemRepository
    {
        public async Task<IEnumerable<OrderItem>> GetOrderItemsByOrderId(Guid orderId)
        {
            return await _dbSet
                .Where(x => x.OrderId == orderId)
                .ToListAsync();
        }
        public async Task<OrderItem> GetOrderItemByProductId(Guid productId)
        {
            return await _dbSet
                .FirstOrDefaultAsync(x => x.ProductId == productId);
        }
        public async Task<OrderItem> GetOrderItemWithProduct(Guid uuid)
        {
            return await _dbSet
                .Include(x => x.Product)
                .FirstOrDefaultAsync(x => x.UUID == uuid);
        }
        public async Task<IEnumerable<OrderItem>> GetAllWithProductAsync()
        {
            return await _dbSet
                .Include(x => x.Product)
                .ToListAsync();
        }
        public async Task<IEnumerable<OrderItem>> GetAll() => await _dbSet.ToListAsync();
    }
}
using Microsoft.EntityFrameworkCore;
using SalesOrderManagement.API.Infra.Context;
using SalesOrderManagement.API.Infra.Repositories._bases;
using SalesOrderManagement.Domain.Entities;
using SalesOrderManagement.Domain.Interfaces.Repositories;
using static SalesOrderManagement.Domain.Entities._bases.Enums;

namespace SalesOrderManagement.API.Infra.Repositories
{
    public class OrderRepository(AppDbContext context) : RepositoryBase<Order>(context), IOrderRepository
    {
        public async Task<IEnumerable<Order>> GetOrdersByUserId(Guid userId)
        {
            return await _dbSet
                .Where(o => o.CreateByUserUuid == userId)
                .ToListAsync();
        }
        public async Task<IEnumerable<Order>> GetOrdersByStatus(OrderStatus status)
        {
            return await _dbSet
                .Where(o => o.Status == status)
                .ToListAsync();
        }
        public async Task<IEnumerable<Order>> GetOrdersByDateRange(DateTime startDate, DateTime endDate)
        {
            return await _dbSet
                .Where(o => o.OrderDate >= startDate && o.OrderDate <= endDate)
                .ToListAsync();
        }
        public async Task<Order> GetOrderWithOrdemItems(Guid uuid)
        {
            return await _dbSet
                .Include(o => o.OrderItems)
                .FirstOrDefaultAsync(o => o.UUID == uuid);
        }
        public async Task<IEnumerable<Order>> GetAllWithItemsAsync()
        {
            return await _dbSet
                .Include(o => o.OrderItems)
                .ToListAsync();
        }
    }
}
using Microsoft.EntityFrameworkCore;
using SalesOrderManagement.API.Infra.Context;
using SalesOrderManagement.API.Infra.Repositories._bases;
using SalesOrderManagement.Domain.Entities;
using SalesOrderManagement.Domain.Interfaces.Repositories;

namespace SalesOrderManagement.API.Infra.Repositories
{
    public class ProductRepository(AppDbContext context) : RepositoryBase<Product>(context), IProductRepository
    {
        public async Task<IEnumerable<Product>> GetAll()
        {
            return await _dbSet.ToListAsync();
        }
        public async Task<IEnumerable<Product>> GetAllByCategory(string category)
        {
            return await _dbSet
                .Where(p => p.Category == category)
                .ToListAsync();
        }
    }
}
using Microsoft.EntityFrameworkCore;
using SalesOrderManagement.API.Infra.Context;
using SalesOrderManagement.API.Infra.Repositories._bases;
using SalesOrderManagement.Domain.Entities;
using SalesOrderManagement.Domain.Interfaces.Repositories;
using static SalesOrderManagement.Domain.Entities._bases.Enums;

namespace SalesOrderManagement.API.Infra.Repositories
{
    public class UserRepository(AppDbContext context) : RepositoryBase<User>(context), IUserRepository
    {
        public async Task<IEnumerable<User>> GetAll()
        {
            return await _dbSet.ToListAsync();
        }

        public async Task<IEnumerable<User>> GetAllByRole(UserRole role)
        {
            return await _dbSet
                .Where(u => u.UserRole == role)
                .ToListAsync();
        }

        public async Task<User> GetByDocument(string document)
        {
            return await _dbSet.FirstOrDefaultAsync(u => u.Document == document);
        }

        public async Task<User> GetByEmail(string email)

        {
            return await _dbSet.FirstOrDefaultAsync(u => u.Email == email);
        }

        public async Task<User> GetByPhone(string phone)
        {
            return await _dbSet.FirstOrDefaultAsync(u => u.Phone == phone);
        }
    }
}

fim da camada de repositorio 
Camada de IOC
using DotNetEnv;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using SalesOrderManagement.API.Infra.Context;
using SalesOrderManagement.API.Infra.Repositories;
using SalesOrderManagement.Application.Business;
using SalesOrderManagement.Application.Dtos.Dashboard;
using SalesOrderManagement.Application.Interfaces;
using SalesOrderManagement.Application.Interfaces.Business;
using SalesOrderManagement.Application.Interfaces.UseCases;
using SalesOrderManagement.Application.Profiles;
using SalesOrderManagement.Application.Services;
using SalesOrderManagement.Application.UseCases;
using SalesOrderManagement.Domain.Interfaces.Repositories;

namespace SalesOrderManagement.API.IOC
{
    public static class Ioc
    {
        public static void ConfigureServicesIoc(IServiceCollection services, IConfiguration configuration, ref string tokenSecret)
        {
            services.ConfigureEnvironmentVariables(configuration, ref tokenSecret, out string connectString);
            services.ConfigureDBContext(configuration, connectString);
            services.ConfigureRepositories();
            services.ConfigureValidators();
            services.ConfigureBusiness();
            services.ConfigureProfiles();
            services.ConfigureUseCases();
            services.ConfigureServices(tokenSecret);
        }

        public static void ConfigureRepositories(this IServiceCollection services)
        {
            services.AddScoped<IUserRepository, UserRepository>();
            services.AddScoped<IOrderRepository, OrderRepository>();
            services.AddScoped<IProductRepository, ProductRepository>();
            services.AddScoped<IOrderItemRepository, OrderItemRepository>();
        }

        public static void ConfigureBusiness(this IServiceCollection services)
        {

            services.AddScoped<IUserBusiness, UserBusiness>();
            services.AddScoped<IOrderBusiness, OrderBusiness>();
            services.AddScoped<IOrderItemBusiness, OrderItemBusiness>();
            services.AddScoped<IProductBusiness, ProductBusiness>();
        }

        public static void ConfigureProfiles(this IServiceCollection services)
        {
            MapsterConfiguration.Configure();
        }

        public static void ConfigureServices(this IServiceCollection services, string tokenSecret)
        {
            services.AddScoped<ITokenService, TokenBusiness>();
        }

        public static void ConfigureValidators(this IServiceCollection services)
        {
            //services.AddSingleton<IValidatorProvider, ValidatorFactory>();
        }

        public static void ConfigureUseCases(this IServiceCollection services)
        {
            services.AddScoped<IUserAuthentication, UserAuthentication>();
            services.AddScoped<IOrderProcessing, OrderProcessing>();
            services.AddScoped<IDashboard, Dashboard>();
        }

        public static void ConfigureEnvironmentVariables(this IServiceCollection services, IConfiguration configuration, ref string tokenSecret, out string connectString)
        {
            Env.TraversePath().Load();
            connectString = Environment.GetEnvironmentVariable("DATABASE_URL");
            if (string.IsNullOrEmpty(connectString))
            {
                connectString = configuration.GetConnectionString("DefaultConnection");
            }
            tokenSecret = Environment.GetEnvironmentVariable("TOKEN_JWT_SECRET");
            if (string.IsNullOrEmpty(tokenSecret))
            {
                tokenSecret = configuration["Jwt:Key"];
            }
            string jwtSecret = tokenSecret;
        }

        public static void ConfigureDBContext(this IServiceCollection services, IConfiguration configuration, string connectString)
        {
            services.AddDbContextPool<AppDbContext>(options =>
                  options.UseNpgsql(connectString, x => x.MigrationsAssembly("SalesOrderManagement.API.Infra")));
        }
    }
}
fim do IOC 
Inicio da API
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Mvc;
using Microsoft.IdentityModel.Tokens;
using Microsoft.OpenApi.Models;
using SalesOrderManagement.API.IOC;
using System.Text;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAll", policy =>
    {
        policy
            .AllowAnyOrigin()
            .AllowAnyHeader()
            .AllowAnyMethod();
    });
});

builder.Services.AddControllers();
// Learn more about configuring OpenAPI at https://aka.ms/aspnet/openapi
builder.Services.AddOpenApi();
builder.Services.AddMemoryCache();
builder.Services.AddAuthorization();

string jwtSecret = string.Empty;
builder.Configuration.AddEnvironmentVariables();
Ioc.ConfigureServicesIoc(services: builder.Services, builder.Configuration, ref jwtSecret);
var key = Encoding.ASCII.GetBytes(jwtSecret);
builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
}).AddJwtBearer(options =>
{
    options.RequireHttpsMetadata = false;
    options.SaveToken = true;
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = false,
        ValidateAudience = false,
        ValidateIssuerSigningKey = true,
        IssuerSigningKey = new SymmetricSecurityKey(key),
        ValidateLifetime = true,
        ClockSkew = TimeSpan.Zero
    };
});

builder.Services.AddEndpointsApiExplorer();

builder.Services.AddApiVersioning(options =>
{
    options.DefaultApiVersion = new ApiVersion(1, 0);
    options.AssumeDefaultVersionWhenUnspecified = true;
    options.ReportApiVersions = true;
});

builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo
    {
        Title = "SalesOrderManagement",
        Description = "Web Api Project",
        Version = "v1 - .NET 9",
    });
    c.SwaggerDoc("v2", new OpenApiInfo { Title = "Minha API", Version = "v2" });

    c.AddSecurityDefinition("Bearer", new Microsoft.OpenApi.Models.OpenApiSecurityScheme
    {
        Name = "Authorization",
        Type = Microsoft.OpenApi.Models.SecuritySchemeType.Http,
        Scheme = "Bearer",
        BearerFormat = "JWT",
        In = Microsoft.OpenApi.Models.ParameterLocation.Header,
        Description = "Insira o token JWT no campo: Bearer {seu token}"
    });

    c.AddSecurityRequirement(new Microsoft.OpenApi.Models.OpenApiSecurityRequirement
    {
        {
            new Microsoft.OpenApi.Models.OpenApiSecurityScheme
            {
                Reference = new Microsoft.OpenApi.Models.OpenApiReference
                {
                    Type = Microsoft.OpenApi.Models.ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            Array.Empty<string>()
        }
    });
});

var app = builder.Build();

// Configure the HTTP request pipeline.
//if (app.Environment.IsDevelopment())
//{
    app.MapOpenApi();
    app.UseSwagger();
    app.UseSwaggerUI();
//}

app.UseHttpsRedirection();
app.UseCors("AllowAll");

app.UseAuthorization();

app.MapControllers();

app.Run();

using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity.Data;
using Microsoft.AspNetCore.Mvc;
using SalesOrderManagement.Application.Interfaces.UseCases;

namespace SalesOrderManagement.API.Controllers
{
    [ApiController]
    [Route("api/auth")]
    [ApiVersion("1.0")]
    public class AuthController(IUserAuthentication authenticationUseCase) : ControllerBase
    {
        private readonly IUserAuthentication _authenticationUseCase = authenticationUseCase;

        [HttpPost("login")]
        [AllowAnonymous]
        public async Task<IActionResult> Login([FromBody] LoginRequest request)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            try
            {
                var response = await _authenticationUseCase.Login(request.Email, request.Password);
                return StatusCode((int)response.StatusCode, response.ApiReponse);

            }

            catch (Exception ex)
            {
                return StatusCode(500, new { message = $"Login failed: {ex.Message}" });
            }
        }

    }
}
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using SalesOrderManagement.Application.Interfaces.UseCases;

namespace SalesOrderManagement.API.Controllers.v1
{
    [ApiController]
    [ApiVersion("1.0")]
    [Route("api/v{version:apiVersion}/[controller]")]
    [Authorize] 
    public class DashboardController(IDashboard dashboardUseCase) : ControllerBase
    {
        private readonly IDashboard _dashboardUseCase = dashboardUseCase;

        [HttpGet("sales-summary")]
        public async Task<IActionResult> GetSalesSummary()
        {
            var response = await _dashboardUseCase.GetSalesSummary();
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpGet("pending-orders-count")]
        public async Task<IActionResult> GetPendingOrdersCount()
        {
            var response = await _dashboardUseCase.GetPendingOrdersCount();
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpGet("most-active-customers")]
        public async Task<IActionResult> GetMostActiveCustomers()
        {
            var response = await _dashboardUseCase.GetMostActiveCustomers();
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }
    }
}
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using SalesOrderManagement.Application.Dtos.Entities.OrderItem;
using SalesOrderManagement.Application.Interfaces.Business;
using System;
using System.Threading.Tasks;

namespace SalesOrderManagement.API.Controllers.v1
{
    [ApiController]
    [ApiVersion("1.0")]
    [Route("api/v{version:apiVersion}/[controller]")]
    public class OrderItemsController(IOrderItemBusiness orderItemBusiness) : ControllerBase
    {
        private readonly IOrderItemBusiness _orderItemBusiness = orderItemBusiness;

        [HttpPost]
        [Authorize] 
        public async Task<IActionResult> CreateOrderItem(CreateOrderItemDto createOrderItemDto)
        {
            var response = await _orderItemBusiness.Add(createOrderItemDto);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpGet("{id:int}")]
        [Authorize]
        public async Task<IActionResult> GetOrderItemById(int id)
        {
            var response = await _orderItemBusiness.Get(id);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpGet("{guid:guid}")]
        [Authorize]
        public async Task<IActionResult> GetOrderItemByGuid(Guid guid)
        {
            var response = await _orderItemBusiness.GetDto(guid);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpGet("orders/{orderId:guid}")]
        [Authorize]
        public async Task<IActionResult> GetOrderItemsByOrderId(Guid orderId)
        {
            var response = await _orderItemBusiness.GetOrderItemsByOrderId(orderId);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpPut("{guid:guid}")]
        [Authorize] 
        public async Task<IActionResult> UpdateOrderItem(Guid guid, UpdateOrderItemDto updateOrderItemDto)
        {
            if (guid != updateOrderItemDto.UUID)
            {
                return BadRequest();
            }
            var response = await _orderItemBusiness.Update(updateOrderItemDto);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpDelete("{id:int}")]
        [Authorize] 
        public async Task<IActionResult> DeleteOrderItemById(int id)
        {
            var response = await _orderItemBusiness.Delete(id);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpDelete("{guid:guid}")]
        [Authorize]
        public async Task<IActionResult> DeleteOrderItemByGuid(Guid guid)
        {
            var response = await _orderItemBusiness.Delete(guid);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }
    }
}
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using SalesOrderManagement.Application.Dtos.Dashboard;
using SalesOrderManagement.Application.Dtos.Entities.Order;
using SalesOrderManagement.Application.Interfaces.Business;
using SalesOrderManagement.Domain.Errors;
using System.Security.Claims;

namespace SalesOrderManagement.API.Controllers.v1
{
    [ApiController]
    [ApiVersion("1.0")]
    [Route("api/v{version:apiVersion}/[controller]")]
    public class OrdersController(IOrderBusiness orderBusiness, OrderProcessing orderProcessing) : ControllerBase
    {
        private readonly IOrderBusiness _orderBusiness = orderBusiness;
        private readonly OrderProcessing _orderProcessing = orderProcessing;

        [HttpPost]
        [Authorize(Roles = "Admin,Client")]
        public async Task<IActionResult> CreateOrder([FromBody] CreateOrderDto createOrderRequest)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            var userIdClaim = HttpContext.User.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier);

            if (userIdClaim == null || !Guid.TryParse(userIdClaim.Value, out var createdByUserUuid))
            {
                return Unauthorized(Error.UNAUTHORIZED);
            }
            createOrderRequest.CreateByUserUuid = createdByUserUuid;
            var response = await _orderProcessing.CreateOrder(createOrderRequest);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpGet("{uuid}")]
        [Authorize]
        public async Task<IActionResult> GetOrder(Guid uuid)
        {
            var response = await _orderBusiness.GetOrderWithOrdemItems(uuid);

            return StatusCode((int)response.StatusCode, response.ApiReponse);

        }

        [HttpGet("user/{userId}")]
        [Authorize(Roles = "Admin,Client")]
        public async Task<IActionResult> GetOrdersByUserId(Guid userId)
        {
            var response = await _orderBusiness.GetOrdersByUserId(userId);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpGet("status/{status}")]
        [Authorize(Roles = "Admin,Client")]
        public async Task<IActionResult> GetOrdersByStatus(string status)
        {
            var response = await _orderBusiness.GetOrdersByStatus(status);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpGet("date-range")]
        [Authorize(Roles = "Admin,Client")]
        public async Task<IActionResult> GetOrdersByDateRange([FromQuery] DateTime startDate, [FromQuery] DateTime endDate)
        {
            if (startDate > endDate)
            {
                return BadRequest("A data de início deve ser anterior à data de fim.");
            }
            var response = await _orderBusiness.GetOrdersByDateRange(startDate, endDate);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpGet]
        [Authorize(Roles = "Admin,Client")]
        public async Task<IActionResult> GetAllOrdersWithItems()
        {
            var response = await _orderBusiness.GetAllWithItemsAsync();
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpPut("{uuid}")]
        [Authorize(Roles = "Admin,Client")]
        public async Task<IActionResult> UpdateOrder(Guid uuid, [FromBody] UpdateOrderDto updateOrderDto)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            if (uuid != updateOrderDto.UUID)
            {
                return BadRequest("O UUID na rota não corresponde ao UUID no corpo da requisição.");
            }

            var response = await _orderBusiness.Update(updateOrderDto);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpDelete("{uuid}")]
        [Authorize(Roles = "Admin,Client")]
        public async Task<IActionResult> DeleteOrder(Guid uuid)
        {
            var response = await _orderBusiness.Delete(uuid);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }
    }
}
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using SalesOrderManagement.Application.Dtos.Entities.Product;
using SalesOrderManagement.Application.Interfaces.Business;

namespace SalesOrderManagement.API.Controllers.v1
{
    [ApiController]
    [ApiVersion("1.0")]
    [Route("api/v{version:apiVersion}/[controller]")]
    public class ProductsController(IProductBusiness productBusiness) : ControllerBase
    {
        private readonly IProductBusiness _productBusiness = productBusiness;

        [HttpPost]
        [Authorize(Roles = "Admin,Seller")]
        public async Task<IActionResult> CreateProduct(CreateProductDto createProductDto)
        {
            var response = await _productBusiness.Add(createProductDto);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpGet("{id:int}")]
        [Authorize]
        public async Task<IActionResult> GetProductById(int id)
        {
            var response = await _productBusiness.Get(id);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpGet("{guid:guid}")]
        [Authorize]
        public async Task<IActionResult> GetProductByGuid(Guid guid)
        {
            var response = await _productBusiness.GetDto(guid);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpGet]
        [Authorize]
        public async Task<IActionResult> GetAllProducts()
        {
            var response = await _productBusiness.GetAll();
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpGet("category/{category}")]
        [Authorize]
        public async Task<IActionResult> GetProductsByCategory(string category)
        {
            var response = await _productBusiness.GetAllByCategory(category);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpPut("{guid:guid}")]
        [Authorize(Roles = "Admin,Seller")]
        public async Task<IActionResult> UpdateProduct(Guid guid, UpdateProductDto updateProductDto)
        {
            if (guid != updateProductDto.UUID)
            {
                return BadRequest();
            }
            var response = await _productBusiness.Update(updateProductDto);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpDelete("{id:int}")]
        [Authorize(Roles = "Admin,Seller")]
        public async Task<IActionResult> DeleteProductById(int id)
        {
            var response = await _productBusiness.Delete(id);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpDelete("{guid:guid}")]
        [Authorize(Roles = "Admin,Seller")]
        public async Task<IActionResult> DeleteProductByGuid(Guid guid)
        {
            var response = await _productBusiness.Delete(guid);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }
    }
}
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using SalesOrderManagement.Application.Dtos.Entities.User;
using SalesOrderManagement.Application.Interfaces.Business;

namespace SalesOrderManagement.API.Controllers.v1
{
    [ApiController]
    [ApiVersion("1.0")]
    [Route("api/v{version:apiVersion}/[controller]")]

    public class UserController(IUserBusiness userBusiness) : ControllerBase
    {
        private readonly IUserBusiness _userBusiness = userBusiness;

        [HttpPost]
        //[Authorize(Roles = "Admin")]
        public async Task<IActionResult> Add([FromBody] CreateUserDto createUserDto)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            var response = await _userBusiness.Add(createUserDto);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpDelete("{id:int}")]
        [Authorize(Roles = "Admin")]
        public async Task<IActionResult> Delete(int id)
        {
            var response = await _userBusiness.Delete(id);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpDelete("{guid:guid}")]
        [Authorize(Roles = "Admin")]
        public async Task<IActionResult> Delete(Guid guid)
        {
            var response = await _userBusiness.Delete(guid);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpGet("{id:int}")]
        [Authorize(Roles = "Admin,Seller")]
        public async Task<IActionResult> Get(int id)
        {
            var response = await _userBusiness.Get(id);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpGet("{guid:guid}")]
        [Authorize(Roles = "Admin,Seller")]
        public async Task<IActionResult> Get(Guid guid)
        {
            var response = await _userBusiness.GetDto(guid);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpPut]
        [Authorize(Roles = "Admin")]
        public async Task<IActionResult> Update([FromBody] UpdateUserDto updateUserDto)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            var response = await _userBusiness.Update(updateUserDto);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

        [HttpPut("change-password")]
        [Authorize()]
        public async Task<IActionResult> ChangePassword([FromBody] ChangePasswordDto changePasswordDto)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            var response = await _userBusiness.ChangePasswordAsync(changePasswordDto);
            return StatusCode((int)response.StatusCode, response.ApiReponse);
        }

    }
}

Json com todas os endpoints OPEN API 

{
  "openapi": "3.0.4",
  "info": {
    "title": "SalesOrderManagement",
    "description": "Web Api Project",
    "version": "v1 - .NET 9"
  },
  "paths": {
    "/api/auth/login": {
      "post": {
        "tags": ["Auth"],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LoginRequest"
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/LoginRequest"
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/LoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/Dashboard/sales-summary": {
      "get": {
        "tags": ["Dashboard"],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/Dashboard/pending-orders-count": {
      "get": {
        "tags": ["Dashboard"],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/Dashboard/most-active-customers": {
      "get": {
        "tags": ["Dashboard"],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/OrderItems": {
      "post": {
        "tags": ["OrderItems"],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateOrderItemDto"
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateOrderItemDto"
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/CreateOrderItemDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/OrderItems/{id}": {
      "get": {
        "tags": ["OrderItems"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "tags": ["OrderItems"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/OrderItems/{guid}": {
      "get": {
        "tags": ["OrderItems"],
        "parameters": [
          {
            "name": "guid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "put": {
        "tags": ["OrderItems"],
        "parameters": [
          {
            "name": "guid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateOrderItemDto"
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateOrderItemDto"
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateOrderItemDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "tags": ["OrderItems"],
        "parameters": [
          {
            "name": "guid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/OrderItems/orders/{orderId}": {
      "get": {
        "tags": ["OrderItems"],
        "parameters": [
          {
            "name": "orderId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/Orders": {
      "post": {
        "tags": ["Orders"],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateOrderDto"
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateOrderDto"
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/CreateOrderDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "get": {
        "tags": ["Orders"],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/Orders/{uuid}": {
      "get": {
        "tags": ["Orders"],
        "parameters": [
          {
            "name": "uuid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "put": {
        "tags": ["Orders"],
        "parameters": [
          {
            "name": "uuid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateOrderDto"
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateOrderDto"
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateOrderDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "tags": ["Orders"],
        "parameters": [
          {
            "name": "uuid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/Orders/user/{userId}": {
      "get": {
        "tags": ["Orders"],
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/Orders/status/{status}": {
      "get": {
        "tags": ["Orders"],
        "parameters": [
          {
            "name": "status",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/Orders/date-range": {
      "get": {
        "tags": ["Orders"],
        "parameters": [
          {
            "name": "startDate",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "endDate",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/Products": {
      "post": {
        "tags": ["Products"],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateProductDto"
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateProductDto"
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/CreateProductDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "get": {
        "tags": ["Products"],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/Products/{id}": {
      "get": {
        "tags": ["Products"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "tags": ["Products"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/Products/{guid}": {
      "get": {
        "tags": ["Products"],
        "parameters": [
          {
            "name": "guid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "put": {
        "tags": ["Products"],
        "parameters": [
          {
            "name": "guid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateProductDto"
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateProductDto"
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateProductDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "tags": ["Products"],
        "parameters": [
          {
            "name": "guid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/Products/category/{category}": {
      "get": {
        "tags": ["Products"],
        "parameters": [
          {
            "name": "category",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/User": {
      "post": {
        "tags": ["User"],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateUserDto"
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateUserDto"
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/CreateUserDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "put": {
        "tags": ["User"],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateUserDto"
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateUserDto"
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateUserDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/User/{id}": {
      "delete": {
        "tags": ["User"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "get": {
        "tags": ["User"],
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/User/{guid}": {
      "delete": {
        "tags": ["User"],
        "parameters": [
          {
            "name": "guid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "get": {
        "tags": ["User"],
        "parameters": [
          {
            "name": "guid",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/api/v{version}/User/change-password": {
      "put": {
        "tags": ["User"],
        "parameters": [
          {
            "name": "version",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChangePasswordDto"
              }
            },
            "text/json": {
              "schema": {
                "$ref": "#/components/schemas/ChangePasswordDto"
              }
            },
            "application/*+json": {
              "schema": {
                "$ref": "#/components/schemas/ChangePasswordDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "ChangePasswordDto": {
        "required": [
          "confirmNewPassword",
          "newPassword",
          "oldPassword",
          "uuid"
        ],
        "type": "object",
        "properties": {
          "uuid": {
            "type": "string",
            "format": "uuid"
          },
          "oldPassword": {
            "minLength": 1,
            "type": "string"
          },
          "newPassword": {
            "minLength": 8,
            "type": "string"
          },
          "confirmNewPassword": {
            "minLength": 1,
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "CreateOrderDto": {
        "required": [
          "billingAddress",
          "orderItems",
          "paymentMethod",
          "shippingAddress"
        ],
        "type": "object",
        "properties": {
          "orderDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "shippingAddress": {
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "billingAddress": {
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          },
          "paymentMethod": {
            "$ref": "#/components/schemas/PaymentMethod"
          },
          "createByUserUuid": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "orderItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateOrderItemDto"
            }
          }
        },
        "additionalProperties": false
      },
      "CreateOrderItemDto": {
        "required": ["orderId", "productId", "quantity"],
        "type": "object",
        "properties": {
          "productId": {
            "type": "string",
            "format": "uuid"
          },
          "orderId": {
            "type": "string",
            "format": "uuid"
          },
          "quantity": {
            "maximum": 2147483647,
            "minimum": 1,
            "type": "integer",
            "format": "int32"
          }
        },
        "additionalProperties": false
      },
      "CreateProductDto": {
        "required": ["category", "name", "price", "quantity"],
        "type": "object",
        "properties": {
          "name": {
            "maxLength": 255,
            "minLength": 1,
            "type": "string"
          },
          "description": {
            "maxLength": 1000,
            "type": "string",
            "nullable": true
          },
          "price": {
            "minimum": 0.01,
            "type": "number",
            "format": "double"
          },
          "quantity": {
            "maximum": 2147483647,
            "minimum": 0,
            "type": "integer",
            "format": "int32"
          },
          "category": {
            "maxLength": 100,
            "minLength": 1,
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "CreateUserDto": {
        "required": ["email", "fullName", "password", "userRole"],
        "type": "object",
        "properties": {
          "fullName": {
            "maxLength": 255,
            "minLength": 1,
            "type": "string"
          },
          "email": {
            "maxLength": 255,
            "minLength": 1,
            "type": "string",
            "format": "email"
          },
          "phone": {
            "maxLength": 20,
            "type": "string",
            "nullable": true
          },
          "password": {
            "minLength": 1,
            "type": "string"
          },
          "document": {
            "maxLength": 18,
            "type": "string",
            "nullable": true
          },
          "userRole": {
            "$ref": "#/components/schemas/UserRole"
          }
        },
        "additionalProperties": false
      },
      "LoginRequest": {
        "required": ["email", "password"],
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "nullable": true
          },
          "password": {
            "type": "string",
            "nullable": true
          },
          "twoFactorCode": {
            "type": "string",
            "nullable": true
          },
          "twoFactorRecoveryCode": {
            "type": "string",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "OrderStatus": {
        "enum": [0, 1, 2, 3, 4, 5],
        "type": "integer",
        "format": "int32"
      },
      "PaymentMethod": {
        "enum": [0, 1, 2, 3, 4],
        "type": "integer",
        "format": "int32"
      },
      "UpdateOrderDto": {
        "required": ["uuid"],
        "type": "object",
        "properties": {
          "uuid": {
            "type": "string",
            "format": "uuid"
          },
          "orderDate": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "shippingAddress": {
            "maxLength": 100,
            "type": "string",
            "nullable": true
          },
          "billingAddress": {
            "maxLength": 100,
            "type": "string",
            "nullable": true
          },
          "paymentMethod": {
            "$ref": "#/components/schemas/PaymentMethod"
          },
          "status": {
            "$ref": "#/components/schemas/OrderStatus"
          },
          "actionedByUserUuid": {
            "type": "string",
            "format": "uuid",
            "nullable": true
          },
          "orderItems": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UpdateOrderItemDto"
            },
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "UpdateOrderItemDto": {
        "required": ["orderId", "productId", "quantity", "uuid"],
        "type": "object",
        "properties": {
          "uuid": {
            "type": "string",
            "format": "uuid"
          },
          "productId": {
            "type": "string",
            "format": "uuid"
          },
          "orderId": {
            "type": "string",
            "format": "uuid"
          },
          "quantity": {
            "maximum": 2147483647,
            "minimum": 1,
            "type": "integer",
            "format": "int32"
          }
        },
        "additionalProperties": false
      },
      "UpdateProductDto": {
        "required": ["uuid"],
        "type": "object",
        "properties": {
          "uuid": {
            "type": "string",
            "format": "uuid"
          },
          "name": {
            "maxLength": 255,
            "type": "string",
            "nullable": true
          },
          "description": {
            "maxLength": 1000,
            "type": "string",
            "nullable": true
          },
          "price": {
            "minimum": 0.01,
            "type": "number",
            "format": "double",
            "nullable": true
          },
          "quantity": {
            "maximum": 2147483647,
            "minimum": 0,
            "type": "integer",
            "format": "int32",
            "nullable": true
          },
          "category": {
            "maxLength": 100,
            "type": "string",
            "nullable": true
          },
          "isActive": {
            "type": "boolean",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "UpdateUserDto": {
        "required": ["uuid"],
        "type": "object",
        "properties": {
          "uuid": {
            "type": "string",
            "format": "uuid"
          },
          "fullName": {
            "maxLength": 255,
            "type": "string",
            "nullable": true
          },
          "email": {
            "maxLength": 255,
            "type": "string",
            "format": "email",
            "nullable": true
          },
          "phone": {
            "maxLength": 20,
            "type": "string",
            "nullable": true
          },
          "document": {
            "maxLength": 18,
            "type": "string",
            "nullable": true
          },
          "userRole": {
            "$ref": "#/components/schemas/UserRole"
          },
          "isActive": {
            "type": "boolean",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "UserRole": {
        "enum": [0, 1, 2],
        "type": "integer",
        "format": "int32"
      }
    },
    "securitySchemes": {
      "Bearer": {
        "type": "http",
        "description": "Insira o token JWT no campo: Bearer {seu token}",
        "scheme": "Bearer",
        "bearerFormat": "JWT"
      }
    }
  },
  "security": [
    {
      "Bearer": []
    }
  ]
}
